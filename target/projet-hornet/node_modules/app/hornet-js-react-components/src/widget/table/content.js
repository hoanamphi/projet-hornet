"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * hornet-js-react-components - Ensemble des composants web React de base de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var array_utils_1 = require("hornet-js-utils/src/array-utils");
var sort_data_1 = require("hornet-js-core/src/component/sort-data");
var React = require("react");
var hornet_component_1 = require("hornet-js-react-components/src/widget/component/hornet-component");
var confirm_1 = require("hornet-js-react-components/src/widget/dialog/confirm");
var spinner_table_1 = require("hornet-js-react-components/src/widget/table/spinner-table");
var paginate_datasource_1 = require("hornet-js-core/src/component/datasource/paginate-datasource");
var columns_1 = require("hornet-js-react-components/src/widget/table/columns");
var action_column_1 = require("hornet-js-react-components/src/widget/table/column/action-column");
var edition_action_column_1 = require("hornet-js-react-components/src/widget/table/column/edition-action-column");
var check_column_1 = require("hornet-js-react-components/src/widget/table/column/check-column");
var abstract_cell_1 = require("hornet-js-react-components/src/widget/table/column/cell/abstract-cell");
var cell_coordinates_1 = require("hornet-js-react-components/src/widget/table/column/cell/cell-coordinates");
var table_state_1 = require("hornet-js-react-components/src/widget/table/table-state");
var navigation_direction_1 = require("hornet-js-react-components/src/widget/table/navigation-direction");
var form_1 = require("hornet-js-react-components/src/widget/form/form");
var line_before_1 = require("hornet-js-react-components/src/widget/table/line/line-before");
var line_after_1 = require("hornet-js-react-components/src/widget/table/line/line-after");
var classNames = require("classnames");
var _ = require("lodash");
var hornet_event_1 = require("hornet-js-core/src/event/hornet-event");
var paginate_datasource_2 = require("hornet-js-core/src/component/datasource/paginate-datasource");
exports.UNIT_SIZE = "em";
exports.UPDATE_COLUMN_VISIBILITY = new hornet_event_1.HornetEvent("UPDATE_COLUMN_VISIBILITY");
/**
 * Modes de d'interaction accessible au clavier
 */
var KeyboardInteractionMode;
(function (KeyboardInteractionMode) {
    /** Navigation en lecture seule avec les flèches */
    KeyboardInteractionMode[KeyboardInteractionMode["NAVIGATION"] = 0] = "NAVIGATION";
    /** Edition : même si les cellules ne sont pas éditables, des boutons d'édition peuvent être disponibles.
     * Ils sont accédés via la tabulation */
    KeyboardInteractionMode[KeyboardInteractionMode["ACTIONABLE"] = 1] = "ACTIONABLE";
})(KeyboardInteractionMode = exports.KeyboardInteractionMode || (exports.KeyboardInteractionMode = {}));
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-react-components.widget.table.content");
/**
 * Classe permettant de générer le rendu graphique d'uncomposant Tableau
 */
var Content = /** @class */ (function (_super) {
    tslib_1.__extends(Content, _super);
    function Content(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.tableTrsRef = [];
        /** Collection de colonne avec coordonnées et état */
        _this.columnsWithVisibilityMap = new Array();
        _this.props.contentState.setMaxListeners(Infinity);
        _this.props.dataSource && _this.props.dataSource.setMaxListeners(Infinity);
        _this.state.keyboardMode = KeyboardInteractionMode.NAVIGATION;
        _this.state.items = [];
        _this.state.inProgress = false;
        _this.state.isContentVisible = true;
        var result = _this.props.dataSource && _this.props.dataSource.results;
        if (result) {
            _this.state.items = _this.props.dataSource instanceof paginate_datasource_1.PaginateDataSource ?
                _this.props.dataSource.getItemsByPage(_this.props.dataSource.pagination.pageIndex || paginate_datasource_2.Direction.FIRST) : result;
            _this.props.dataSource.select([]);
        }
        _this.state.spinner = false;
        _this.state.actionMassEnabled = _this.hasChildrenOfComponentTypeOf(columns_1.Columns, check_column_1.CheckColumn);
        var columnKeyActionMass = null;
        _this.hiddenColumns = props.hiddenColumns;
        _this.totalColumns = _this.getTotalColumnsVisible();
        _this.props.contentState.on(table_state_1.ContentState.TOGGLE_COLUMNS_EVENT, _this.handleChangeHiddenColumns);
        if (_this.props.dataSource && _this.props.dataSource.getDefaultSort()) {
            _this.sortData = _this.props.dataSource.getDefaultSort().sort;
        }
        // chaque cellule ecoute levent de clic sur l'icone d'edition d'une ligne du tableau
        _this.handleEdition = _this.handleEdition.bind(_this);
        _this.props.contentState.on(table_state_1.ContentState.EDITION_CLIC_EVENT, _this.handleEdition);
        _this.initializeColumnVisibilityWithCoord();
        return _this;
    }
    /**
     * @inheritDoc
     */
    Content.prototype.componentDidMount = function () {
        _super.prototype.componentDidMount.call(this);
        var result = this.props.dataSource.results;
        if (result) {
            if (this.props.dataSource instanceof paginate_datasource_1.PaginateDataSource) {
                // nothing
            }
            else {
                this.props.contentState.setItems(result);
            }
        }
        this.props.dataSource.on("init", this.setItem);
        this.props.dataSource.on("fetch", this.setItem);
        this.props.dataSource.on("pagination", this.setItemPaginate);
        this.props.dataSource.on("sort", this.sort);
        this.props.dataSource.on("delete", this.setItem);
        this.props.dataSource.on("add", this.setItem);
        this.props.dataSource.on("filter", this.setItem);
        this.props.dataSource.on("loadingData", this.displaySpinner);
        this.props.dataSource.on("select", this.handleChangeSelectedItems.bind(this));
        this.listen(exports.UPDATE_COLUMN_VISIBILITY, this.updateColumnVisibility);
    };
    /**
     * @inheritDoc
     */
    Content.prototype.componentWillUnmount = function () {
        _super.prototype.componentWillUnmount.call(this);
        this.props.dataSource.removeListener("fetch", this.setItem);
        this.props.dataSource.removeListener("init", this.setItem);
        this.props.dataSource.removeListener("pagination", this.setItemPaginate);
        this.props.dataSource.removeListener("sort", this.sort);
        this.props.dataSource.removeListener("add", this.setItem);
        this.props.dataSource.removeListener("filter", this.setItem);
        this.props.dataSource.removeListener("delete", this.setItem);
        this.props.dataSource.removeListener("loadingData", this.displaySpinner);
        this.props.dataSource.removeListener("select", this.handleChangeSelectedItems.bind(this));
        this.remove(exports.UPDATE_COLUMN_VISIBILITY, this.updateColumnVisibility);
    };
    /**
     * @inheritDoc
     */
    Content.prototype.render = function () {
        logger.trace("rendu du tableau ", this.state.onSubmit ? "avec un formulaire" : "sans formulaire");
        // On réinitialise les tableau des ref liées aux Tr
        this.tableTrsRef = [];
        // lorque la fonction submit est definit, on met le content dans un composant form
        return (this.state.onSubmit && !this.props.withoutForm ?
            React.createElement(form_1.Form, { ref: "lineForm", hideButtons: true, className: "form-table", schema: this.state.schema, id: this.state.idForm, notifId: this.state.notifId, onSubmit: this.handleSubmit, isMandatoryFieldsHidden: true }, this.renderContent()) : this.renderContent());
    };
    /**
     * Calcule le nombre de colonnes à afficher
     * @returns {number}
     */
    Content.prototype.getTotalColumnsVisible = function () {
        var nbColumns = this.getChildrenOf(columns_1.Columns).length;
        if (this.hiddenColumns) {
            nbColumns -= _.keys(_.pickBy(this.hiddenColumns, _.identity)).length;
        }
        return nbColumns;
    };
    /**
     * Calcule le nombre de colonnes à afficher
     * @returns {number}
     */
    Content.prototype.getTotalColumnsVisibleFromState = function () {
        var visibleColumnState = this.columnsWithVisibilityMap.filter(function (columnState) {
            if (columnState.isVisible) {
                return true;
            }
        });
        return visibleColumnState.length;
    };
    /**
     * Méthode permettant de mettre à jour le nombre de colonnes
     * @param hiddenColumns
     */
    Content.prototype.handleChangeHiddenColumns = function (hiddenColumns) {
        this.hiddenColumns = hiddenColumns;
        this.totalColumns = this.getTotalColumnsVisible();
    };
    /**
     * met a true la props isEditing a true lorsque la cellule est en cours d'edition
     * @param lineIndex
     */
    Content.prototype.handleEdition = function (lineIndex) {
        if (Array.isArray(this.tableTrsRef)) {
            this.tableTrsRef.map(function (tr, index) {
                if (tr.instance && tr.instance.classList) {
                    var list = tr.instance.classList;
                    (index === lineIndex) ? list.add("datatable-line-selected") : list.remove("datatable-line-selected");
                }
            });
        }
    };
    /**
     * Méthode qui controle l'affichage et la suppression du spinner
     * @param flag booléen true pour l'afficher false sinon
     */
    Content.prototype.displaySpinner = function (flag) {
        if (!this.props.hideSpinner) {
            flag ? this.showSpinnerComponent() : this.hideSpinnerComponent();
        }
    };
    /**
     * Méthode permettant de setter les data dans le tableau
     * @param result tableau d'élément
     */
    Content.prototype.setItem = function (result) {
        var _this = this;
        this.props.contentState.setItems(result);
        this.setState({ items: result }, function () {
            if (_this.tBodyRef && _this.tBodyRef.scrollHeight > _this.tBodyRef.clientHeight && _this.state.items.length > 0) {
                _this.props.contentState.emit(table_state_1.ContentState.RESIZE_EVENT, _this.props.width - 1.2);
            }
        });
    };
    /**
     * Méthode permettant de setter les data dans le tableau
     * @param result tableau d'éléments
     */
    Content.prototype.setItemPaginate = function (result) {
        var _this = this;
        this.props.contentState.setItems(result.list);
        this.setState({ items: result.list }, function () {
            if (_this.tBodyRef && _this.tBodyRef.scrollHeight > _this.tBodyRef.clientHeight && _this.state.items.length > 0) {
                _this.props.contentState.emit(table_state_1.ContentState.RESIZE_EVENT, _this.props.width - 1.2);
            }
        });
    };
    /**
     * Méthode permettant de tri les data
     * @param result tableau d'éléments
     * @param {SortData[]} sortData critères de tri.
     */
    Content.prototype.sort = function (result, sortData) {
        var _this = this;
        this.props.contentState.setItems(result);
        this.sortData = sortData;
        this.setState({ items: result }, function () {
            if (_this.thElementToFocus) {
                abstract_cell_1.AbstractCell.setCellTabIndex(_this.thElementToFocus, 0, true);
            }
        });
    };
    /**
     * @inheritDoc
     */
    Content.prototype.setDataSource = function (value, callback) {
        this.setState({ dataSource: value }, callback);
        return this;
    };
    /**
     * Fonction de validation du formulaire
     * elle rappel la fonction de validation passé dans les props avec l'item qui etait en cours d'edition mis a jour avec les valeurs saisies
     * @param data
     */
    Content.prototype.handleSubmit = function (data) {
        var _this = this;
        if (this.state.onSubmit) {
            var item_1 = this.props.contentState.itemInEdition;
            // merge les data avec l'item
            for (var name_1 in data) {
                if (item_1[name_1]) {
                    item_1[name_1] = data[name_1];
                }
            }
            Promise.resolve()
                .then(function () {
                _this.state.onSubmit(item_1);
            })
                .then(function () {
                _this.props.contentState.setItemInEdition(null, null);
            });
        }
    };
    /**
     * Rendu du content
     * @returns {any}
     */
    Content.prototype.renderContent = function () {
        logger.trace("renderContent ");
        var columns = this.initColumnsProps();
        if (this.props.dataSource.results.length > 500) {
            console.log("TROP DE DATA POUR LE TABLEAU");
        }
        var tableProps = {
            role: "grid",
            "aria-readonly": "true",
            key: this.props.id,
            id: this.props.id
        };
        var headerTable = this.state.isContentVisible ? this.renderTHeader(columns) : null;
        return (React.createElement("div", { className: "datatable-content", tabIndex: this.state.tabIndex },
            React.createElement(spinner_table_1.SpinnerOverlay, { ref: "spinnerOverlay", isVisible: this.state.spinner, onHideSpinner: this.onHideSpinner, nbColumns: this.getTotalColumnsVisible(), width: this.props.width }),
            React.createElement("table", tslib_1.__assign({}, tableProps, { summary: this.props.summary }),
                this.renderCaption(columns),
                headerTable,
                this.renderTBody(columns)),
            React.createElement(confirm_1.Confirm, { ref: "alert", message: "", onClickCancel: this.closeAlert, onClickClose: this.closeAlert })));
    };
    /**
     * Rendu HTML du caption avec notion d'ordre de tri (si tri il y a)
     * @param columns
     * @returns {any}
     */
    Content.prototype.renderCaption = function (columns) {
        var _this = this;
        var title = this.props.title;
        if (this.sortData) {
            columns.map(function (column) {
                if (column.props) {
                    var sortColumn = _.find(_this.sortData, { key: column.props.keyColumn });
                    if (sortColumn) {
                        title += ":" + _this.i18n("table.sortedByTitle", { columnTitle: column.props.title }) + " ";
                        title += sortColumn.dir == sort_data_1.SortDirection.ASC ? _this.i18n("table.ascending") : _this.i18n("table.descending");
                    }
                }
            });
        }
        return (React.createElement("caption", { className: "hidden" }, title));
    };
    /**
     * Evènement permettant de déclencher le tri
     * @param sortData
     */
    Content.prototype.onSort = function (sortData, thElement, compareMethod) {
        var conf = sortData;
        this.sortData = [sortData];
        if (this.state.clientSideSorting) {
            conf.clientSideSorting = true;
        }
        this.thElementToFocus = thElement;
        var options = { sortDatas: [sortData] };
        if (compareMethod) {
            options["compare"] = compareMethod;
        }
        this.props.dataSource.sort(options);
    };
    /**
     * Rendu du header du tableau HTML
     * @param columns: colonnes déclarées dans le composant Page
     * @returns {any}
     */
    Content.prototype.renderTHeader = function (columns) {
        var classnameThead = classNames({
            "datatable-columns": !this.state.headerFixed,
            "datatable-columns-fixed": this.state.headerFixed && this.state.items.length > 0,
            "datatable-columns-disabled": this.state.items.length == 0,
            "datatale-columns-hidden": this.props.headerHidden ? true : false
        });
        var tHeadProps = {
            className: classnameThead,
            id: this.props.id + "-thead"
        };
        return (React.createElement("thead", tslib_1.__assign({}, tHeadProps),
            React.createElement("tr", { id: this.props.id + "-tr-header" }, this.renderRowHeader(columns)),
            React.createElement(spinner_table_1.SpinnerLoader, { ref: "spinnerLoader", isVisible: this.state.spinner, className: this.props.id, nbColumns: this.getTotalColumnsVisible() })));
    };
    /**
     * Rendu HTML d'un ligne du composant Table
     * @param columns: colonnes déclaréesisContentVisible dans le composant Page
     * @returns {any}
     */
    Content.prototype.renderRowHeader = function (columns) {
        var _this = this;
        var Ths = [];
        logger.trace("renderRowHeader ");
        var selectedElements = this.props.dataSource ? this.props.dataSource.selected : [];
        columns.map(function (column, index) {
            var props = _this.getColProps(columns, index);
            var sortColumn = _.find(_this.sortData, { key: column.props.keyColumn });
            if (_this.sortData && sortColumn) {
                props.sortData = sortColumn;
            }
            // si la colonne ne contient que le checkBox, on applique pas (text-overflow: ellipsis;)
            if (column.type == check_column_1.CheckColumn) {
                props.className = classNames({ "datatable-header-no-text-overflow": true });
            }
            props.isSelected = array_utils_1.ArrayUtils.isInclude(_this.props.contentState.items, selectedElements);
            props.onSort = _this.onSort.bind(_this);
            props.cellCoordinate = new cell_coordinates_1.CellCoordinates(index, -1);
            props.isHeader = true;
            props.style = props.style || column.props.style;
            props.key = _this.state.id + "-" + props.cellCoordinate.row + "-" + props.cellCoordinate.column + "-wrapped";
            var Wrapped = hornet_component_1.HornetComponent.wrap(column.type, column, props, column.props);
            var col = React.createElement(Wrapped, { key: "wc-" + props.key });
            Ths.push(col);
        });
        return Ths;
    };
    Content.prototype.renderDatatableMessage = function (content) {
        logger.trace("renderDatatableMessage ");
        var tdProps = {};
        tdProps.colSpan = this.totalColumns;
        tdProps.className = classNames({ "datatable-message-content": true, "txtcenter": true });
        tdProps.style = { width: this.state.width + exports.UNIT_SIZE };
        return (React.createElement("tr", { key: "emptyRow" },
            React.createElement("td", tslib_1.__assign({}, tdProps), content)));
    };
    /**
     * Crée le body du tableau HTML
     * @param columns
     * @returns {any}
     */
    Content.prototype.renderTBody = function (columns) {
        var _this = this;
        logger.trace("renderTBody ");
        var rows = [];
        if (!(this.state.items && this.state.items.length > 0 && this.state.isContentVisible)) {
            // Cas d'un tableau sans résultats
            rows.push(this.renderDatatableMessage(this.state.emptyResult || this.i18n("table.emptyResult")));
        }
        else {
            this.state.items.map(function (item, lineIndex) {
                var rowBefore = _this.renderExpandableRow(item, columns, lineIndex, true);
                if (rowBefore) {
                    rows.push(rowBefore);
                }
                rows.push(_this.renderRowBody(item, columns, lineIndex));
                var rowAfter = _this.renderExpandableRow(item, columns, lineIndex);
                if (rowAfter) {
                    rows.push(rowAfter);
                }
            });
        }
        var classNameTbody = classNames({
            "datatable-data": !this.props.headerFixed,
            "datatable-data-fixed": this.state.headerFixed && this.state.items.length > 0
        });
        var tBodyProps = {
            className: classNameTbody,
            ref: function (element) { return _this.tBodyRef = element; }
        };
        // if (!this.props.headerFixed) {
        //     tBodyProps.style = {
        //         width: this.props.width + UNIT_SIZE
        //     }
        // }
        return (React.createElement("tbody", tslib_1.__assign({}, tBodyProps), rows));
    };
    /**
     * Rendu HTML d'une ligne LineAfter
     * @param item
     * @param columns
     * @param lineIndex
     * @param isBefore
     * @returns {any}
     */
    Content.prototype.renderExpandableRow = function (item, columns, lineIndex, isBefore) {
        var _this = this;
        logger.trace("renderExpandableRow ");
        var ComponentType = isBefore ? line_before_1.LineBefore : line_after_1.LineAfter;
        var rowType = isBefore ? "before" : "after";
        var cells = [], row = null;
        columns.map(function (column, index) {
            var children = Content.getChildrenFrom(column, ComponentType);
            var props = _this.getColProps(columns, index);
            props.cellCoordinate = new cell_coordinates_1.CellCoordinates(index, lineIndex);
            if (children && Array.isArray(children) && children.length > 0) {
                var LineComponent = Content.getComponentFromParentBy(column, ComponentType);
                var headersHtmlAttr_1 = "";
                if (column.props.headers && Array.isArray(column.props.headers)) {
                    column.props.headers.map(function (headerKey) {
                        var idx = _.findIndex(columns, { props: { keyColumn: headerKey } });
                        if (idx > -1)
                            headersHtmlAttr_1 += props.key = _this.props.id + "-colHeader-0-" + idx + " ";
                    });
                }
                else {
                    headersHtmlAttr_1 = column.props.headers;
                }
                if (!LineComponent.props.visible || (LineComponent.props.visible && LineComponent.props.visible(item))) {
                    var colSpan = _this.totalColumns;
                    var kids_1 = [];
                    children.map(function (child, i) {
                        var Wrapped = Content.wrap(child.type, child, child.props, {
                            value: item,
                            rowType: rowType,
                            key: _this.props.id + "expandable-line-wrapped" + index + "-" + i + "-" + lineIndex
                        });
                        kids_1.push(React.createElement(Wrapped, null));
                    });
                    cells.push(React.createElement("td", { colSpan: colSpan, headers: headersHtmlAttr_1, key: _this.props.id + "-expandable-line-cell" + rowType + "-" + lineIndex },
                        React.createElement("div", null, kids_1)));
                    var key = _this.props.id + "-expandable-line-" + rowType + "-" + lineIndex;
                    var TrClassName = {
                        "datatable-expandable-line": true,
                        "datatable-expandable-line-hidden": !LineComponent.props.displayed,
                        "datatable-expandable-line-displayed": LineComponent.props.displayed
                    };
                    TrClassName[_this.props.id + "-tr-with-colspan"] = true;
                    var trProps = {
                        ref: function (instance) {
                            if (instance) {
                                // referme les lignes expanded.
                                instance.classList.add("datatable-expandable-line-hidden");
                                instance.classList.remove("datatable-expandable-line-displayed");
                            }
                        },
                        style: {},
                        id: key,
                        key: key,
                        className: classNames(TrClassName)
                    };
                    row = React.createElement("tr", tslib_1.__assign({}, trProps), cells);
                }
            }
        });
        return row;
    };
    /**
     * Rendu HTML d'une ligne de tableau
     * @param item
     * @param columns
     * @param lineIndex
     * @returns {any}
     */
    Content.prototype.renderRowBody = function (item, columns, lineIndex) {
        var _this = this;
        logger.trace("renderRowBody ");
        var tds = [];
        var classNamesRow = {};
        var isSelected = array_utils_1.ArrayUtils.getIndexById(this.props.dataSource.selected, item) !== -1;
        // Injection de la class CSS surchargée
        if (this.state.customRowsClass) {
            classNamesRow = this.state.customRowsClass(item);
        }
        classNamesRow["datatable-odd"] = (lineIndex % 2) != 0;
        classNamesRow["datatable-even"] = (lineIndex % 2) == 0;
        columns.map(function (column, index) {
            var props = _this.getColProps(columns, index);
            props.value = item;
            props.isSelected = isSelected;
            props.cellCoordinate = new cell_coordinates_1.CellCoordinates(index, lineIndex);
            props.key = _this.props.id + "-columns-colBody-" + props.cellCoordinate.row + "-" + props.cellCoordinate.column + "-wrapped";
            props.style = props.style || column.props.style;
            // TODO: voi si on peut accéder aux propriétés d'un ActionColumn et s'assurer qu'elles matchent avec l'interface
            if (column.type === action_column_1.ActionColumn
                || column.type === edition_action_column_1.EditionActionColumn) {
                props.showAlert = _this.showAlert;
            }
            var Wrapped = hornet_component_1.HornetComponent.wrap(column.type, column, props, column.props);
            var wrappedElement = React.createElement(Wrapped, { key: "wc-" + props.key });
            tds.push(wrappedElement);
        });
        var trProps = {
            ref: function (instance) {
                if (instance) {
                    _this.tableTrsRef.push({ "instance": instance, "value": item });
                    Content.updateClasslistSelectedLine(instance, isSelected);
                }
            },
            key: this.props.id + "-line-" + lineIndex,
            className: classNames(classNamesRow),
            role: "row"
        };
        return (React.createElement("tr", tslib_1.__assign({}, trProps), tds));
    };
    /**
     * Evènement lancé lors d'une déctection de sélection de ligne: ajout/suppression d'une class
     */
    Content.prototype.handleChangeSelectedItems = function (selectedItems) {
        this.tableTrsRef.map(function (element) {
            if (element && element.instance.classList) {
                if (_.findIndex(selectedItems, { "id": element.value.id }) !== -1) {
                    if (!element.instance.classList.contains("datatable-line-selected")) {
                        element.instance.classList.add("datatable-line-selected");
                    }
                }
                else if (element.instance.classList.contains("datatable-line-selected")) {
                    element.instance.classList.remove("datatable-line-selected");
                }
            }
        });
    };
    /**
     * Initialisation des colonnes et des propriétés associées
     * @returns {columns}
     */
    Content.prototype.initColumnsProps = function () {
        logger.trace("initColumnsProps ");
        var columns = this.getChildrenOf(columns_1.Columns);
        if (this.props.headerFixed) {
            columns = this.fixColumnsWidth(columns);
        }
        return columns;
    };
    /***
     * Méthode permettant de fixer la largeur des colonnes dans le cas d'un header Fixe
     * @param columns
     * @returns {any}
     */
    Content.prototype.fixColumnsWidth = function (columns) {
        logger.trace("fixColumnsWidth ");
        var totalColumnWidth = this.state.width;
        var nbColumnsWithoutDefaultWidth = 0;
        columns.map(function (cell) {
            if (cell.props.width) {
                totalColumnWidth = totalColumnWidth - cell.props.width;
            }
            else {
                nbColumnsWithoutDefaultWidth++;
            }
        });
        var defaultColumnWidth = totalColumnWidth / nbColumnsWithoutDefaultWidth;
        columns.map(function (cell, index) {
            if (!cell.props.width) {
                columns[index].props.width = defaultColumnWidth;
            }
        });
        return columns;
    };
    /**
     * Modifie le mode d'accessibilité au clavier
     * @param mode NAVIGATION ou ACTIONABLE
     */
    Content.prototype.handleChangeKeyboardMode = function (mode) {
        /* La condition permet d'éviter de mettre à jour inutilement l'état React et ainsi de déclencher un rendu complet */
        if (mode != this.state.keyboardMode) {
            this.setState({
                keyboardMode: mode
            });
        }
    };
    /**
     * Méthode premettant d'afficher le spinner
     * @returns {Table}
     */
    Content.prototype.showSpinnerComponent = function () {
        this.refs.spinnerLoader.progress(true);
        this.refs.spinnerOverlay.progress(true);
        return this;
    };
    /**
     * Méthode premettant de masquer le spinner
     * @returns {Table}
     */
    Content.prototype.hideSpinnerComponent = function () {
        this.refs.spinnerLoader.progress(false);
        this.refs.spinnerOverlay.progress(false);
        return this;
    };
    /**
     * Méthode déclenchant la fermeture de la fenêtre modale de suppresion d'un partenaire
     */
    Content.prototype.closeAlert = function () {
        this.refs.alert.close();
    };
    /**
     * Méthode déclenchant la fermeture de la fenêtre modale de suppresion d'un partenaire
     */
    Content.prototype.validateAlert = function (fct) {
        this.refs.alert.close(fct);
    };
    /***
     * Déclenche l'affichage de la modale de suppression d'un partenaire
     * @param message
     * @param title
     * @param {Function} fct fonction exécutée sur la validation
     */
    Content.prototype.showAlert = function (message, title, fct) {
        var _this = this;
        this.refs.alert.setMessage(message);
        this.refs.alert.setTitle(title);
        this.refs.alert.setOnClickOk(function () {
            _this.validateAlert(fct);
        }).open();
    };
    /**
     *  Méthode permettant de cocher/décocher une(des) ligne(s) du tableau
     * @param item (l'item selectioonné : deselectioné)
     * @param selectAll (le teoggle de selection multiple
     */
    Content.prototype.toggleSelectLines = function (item) {
        if (this.state.contentState.hasCheckColumnMassSelection) {
            var items = _.cloneDeep(this.state.items);
            // recupere la liste des items selectionnés sur la page courante
            var selectedItems = array_utils_1.ArrayUtils.intersectionWith(this.props.dataSource.selected, this.props.dataSource.results, this.state.contentState.keyColumnMassSelection);
            if (item) {
                this.removeOrPush(selectedItems, item, true);
            }
            else if (selectedItems.length != items.length) {
                // si le tableau porte une sélection multiple
                selectedItems = items;
            }
            else {
                var data = items;
                selectedItems = selectedItems;
                for (var i = 0; i < data.length; i++) {
                    this.removeOrPush(selectedItems, data[i]);
                }
            }
            this.props.dataSource.select(selectedItems);
        }
    };
    /**
     * retourne l'intersection de deux liste
     * @param object
     * @param other
     * @returns {any[]}
     */
    Content.prototype.intersectionWith = function (object, other) {
        var _this = this;
        var listResult = _.intersectionWith(object, other, function (item1, item2) {
            return item1[_this.state.contentState.keyColumnMassSelection] === item2[_this.state.contentState.keyColumnMassSelection];
        });
        return listResult;
    };
    /**
     * retourne l'intersection de deux liste
     * @param object
     * @param other
     * @returns {any[]}
     */
    Content.intersectionWith = function (object, other) {
        var listResult = _.intersectionWith(object, other, function (item1, item2) {
            return item1.id === item2.id;
        });
        return listResult;
    };
    /***
     *
     * @param coordinates coordonnées de la cellule qui a déclenché la navigation
     * @param direction sens de la direction choisie
     */
    Content.prototype.navigateToCell = function (coordinates, direction) {
        var focusCell = null;
        var targetColumn;
        var columnState;
        switch (direction) {
            case navigation_direction_1.NavigateDirection.BOTOM:
                focusCell = new cell_coordinates_1.CellCoordinates(coordinates.column, Math.min(this.state.items.length, coordinates.row + 1));
                break;
            case navigation_direction_1.NavigateDirection.TOP:
                focusCell = new cell_coordinates_1.CellCoordinates(coordinates.column, Math.max(-1, coordinates.row - 1));
                break;
            case navigation_direction_1.NavigateDirection.LEFT:
                targetColumn = coordinates.column - 1;
                columnState = this.columnsWithVisibilityMap[targetColumn];
                while (columnState && !columnState.isVisible) {
                    targetColumn -= 1;
                    columnState = this.columnsWithVisibilityMap[targetColumn];
                }
                if (columnState) {
                    focusCell = new cell_coordinates_1.CellCoordinates(targetColumn, coordinates.row);
                }
                break;
            case navigation_direction_1.NavigateDirection.RIGHT:
                targetColumn = coordinates.column + 1;
                columnState = this.columnsWithVisibilityMap[targetColumn];
                while (columnState && !columnState.isVisible) {
                    targetColumn += 1;
                    columnState = this.columnsWithVisibilityMap[targetColumn];
                }
                if (columnState) {
                    focusCell = new cell_coordinates_1.CellCoordinates(targetColumn, coordinates.row);
                }
                break;
            case navigation_direction_1.NavigateDirection.HOME_COL:
                targetColumn = 0;
                columnState = this.columnsWithVisibilityMap[targetColumn];
                while (columnState && !columnState.isVisible) {
                    targetColumn += 1;
                    columnState = this.columnsWithVisibilityMap[targetColumn];
                }
                focusCell = new cell_coordinates_1.CellCoordinates(targetColumn, coordinates.row);
                break;
            case navigation_direction_1.NavigateDirection.END_COL:
                targetColumn = this.columnsWithVisibilityMap.length - 1;
                columnState = this.columnsWithVisibilityMap[targetColumn];
                while (columnState && !columnState.isVisible) {
                    targetColumn -= 1;
                    columnState = this.columnsWithVisibilityMap[targetColumn];
                }
                focusCell = new cell_coordinates_1.CellCoordinates(targetColumn, coordinates.row);
                break;
            case navigation_direction_1.NavigateDirection.HOME_LINE:
                focusCell = new cell_coordinates_1.CellCoordinates(coordinates.column, 0);
                break;
            case navigation_direction_1.NavigateDirection.END_LINE:
                var items = this.state.items;
                focusCell = new cell_coordinates_1.CellCoordinates(coordinates.column, items.length - 1);
                break;
        }
        //verifier que la table n'est pas en edition
        //sinon verifier que la cellule n'est pas disabled
        if (!this.props.contentState.itemInEdition) {
            this.props.contentState.setFocusOn(focusCell);
        }
        else if (focusCell.row === this.props.contentState.itemInEdition.row) {
            this.props.contentState.setFocusOn(focusCell);
        }
    };
    /***
     * Méthode permettant de récupérer les propriétés d'une cellule
     * @param columns: colonnes déclarées dans le composant Page
     * @param columnIndex: Index de colonne
     * @returns {any} Propriétés d'une cellule
     */
    Content.prototype.getColProps = function (columns, columnIndex) {
        logger.trace("getColProps ");
        var props = {};
        props.coordinates = { column: columnIndex };
        props.handleChangeKeyboardMode = this.handleChangeKeyboardMode;
        props.toggleSelectLines = this.toggleSelectLines.bind(this);
        props.nbColumns = columns.length;
        props.actionMassEnabled = this.state.actionMassEnabled;
        props.navigateFct = this.navigateToCell.bind(this);
        props.keyboardMode = this.state.keyboardMode;
        props.headerFixed = this.props.headerFixed;
        props.contentState = this.props.contentState;
        props.dataSource = this.props.dataSource;
        props.id = this.props.id;
        var style = Content.mergeObjects({}, columns[columnIndex].props.style);
        if (columns[columnIndex].props.width) {
            style["width"] = columns[columnIndex].props.width;
        }
        // Permet de masquer des colonnes par défaut
        if (this.hiddenColumns && this.hiddenColumns[columns[columnIndex].props.keyColumn]) {
            style.display = "none";
            this.hiddenColumns["hidden_" + columnIndex] = props.keyColumn;
        }
        else {
            style.display = "table-cell";
        }
        props.style = Content.mergeObjects(columns[columnIndex].props.defaultStyle, style);
        return props;
    };
    /**
     * permet de supprimer ou d'ajouter l'item dans la liste selectedItems
     * et de le supprimer dans le dataSource.
     * @param selectedItems
     * @param item
     * @param orPush
     */
    Content.prototype.removeOrPush = function (selectedItems, item, orPush) {
        var indexOf = array_utils_1.ArrayUtils.getIndexById(selectedItems, item);
        if (indexOf !== -1) {
            selectedItems.splice(indexOf, 1);
            this.props.dataSource.removeUnSelectedItem(item);
        }
        else if (orPush) {
            selectedItems.push(item);
        }
    };
    /**
     * Méthode qui met a jour le style css pour la selection des lignes
     * @param instance
     * @param isSelected
     */
    Content.updateClasslistSelectedLine = function (instance, isSelected) {
        if (isSelected && !instance.classList.contains("datatable-line-selected")) {
            instance.classList.add("datatable-line-selected");
        }
        else if (!isSelected) {
            instance.classList.remove("datatable-line-selected");
        }
    };
    /**
     * met à jour la visibilité d'une colonne dans la collection référentielle
     * Cette méthode est déclenchée par un HornetEvent
     * @param ev hornetEvent contenant la valeur en booléen sur le visibilité de la colonne
     */
    Content.prototype.updateColumnVisibility = function (ev) {
        this.columnsWithVisibilityMap.map(function (state) {
            if (typeof ev.detail == "string") {
                if (state.column == ev.detail) {
                    state.isVisible = !state.isVisible;
                }
            }
            else {
                var myObject = ev.detail;
                if (state.column == myObject.column) {
                    state.isVisible = myObject.isVisible;
                }
            }
        });
        this.setFirstVisibleColumnState();
    };
    /**
     * Initilisation des états de visibilité des colonnes
     * On commence à true car les colonnes masquées par défaut
     * seront traitées dans le ToggleColumnsButton
     * et que celles ne pouvant pas être maquées et donc toujours visibles
     * ne sont pas gérées dans le ToggleColumnsButton
     */
    Content.prototype.initializeColumnVisibilityWithCoord = function () {
        var _this = this;
        var columns = this.getChildrenOf(columns_1.Columns);
        columns.forEach(function (column, index) {
            if (column) {
                _this.columnsWithVisibilityMap.push({
                    column: column.props.keyColumn,
                    coordinates: index,
                    isVisible: true
                });
            }
        });
        this.setFirstVisibleColumnState();
    };
    /**
     * Propage dans le contentState le columnState de la première column visible
     *
     */
    Content.prototype.setFirstVisibleColumnState = function () {
        var visibleColumnStates = this.columnsWithVisibilityMap.filter(function (column) {
            if (column.isVisible) {
                return true;
            }
        });
        this.props.contentState.setFirstVisibleColumnState(visibleColumnStates[0]);
    };
    /**
     * méthode appelée lors de l'effacement du spinner
     */
    Content.prototype.onHideSpinner = function () {
        if (this.thElementToFocus) {
            this.thElementToFocus = document.getElementById(this.thElementToFocus.id);
            if (this.thElementToFocus) {
                abstract_cell_1.AbstractCell.setCellTabIndex(this.thElementToFocus, 0, true);
            }
        }
    };
    return Content;
}(hornet_component_1.HornetComponent));
exports.Content = Content;

//# sourceMappingURL=content.js.map
