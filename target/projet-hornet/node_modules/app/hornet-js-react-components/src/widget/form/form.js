"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * hornet-js-react-components - Ensemble des composants web React de base de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var React = require("react");
var notification_1 = require("hornet-js-react-components/src/widget/notification/notification");
var abstract_field_1 = require("hornet-js-react-components/src/widget/form/abstract-field");
var abstract_form_1 = require("hornet-js-react-components/src/widget/form/abstract-form");
var upload_file_field_1 = require("hornet-js-react-components/src/widget/form/upload-file-field");
var form_utils_1 = require("hornet-js-react-components/src/widget/form/form-utils");
var dom_adapter_1 = require("hornet-js-react-components/src/widget/form/dom-adapter");
var auto_complete_field_1 = require("hornet-js-react-components/src/widget/form/auto-complete-field");
var notification_manager_1 = require("hornet-js-core/src/notification/notification-manager");
var checkbox_field_1 = require("hornet-js-react-components/src/widget/form/checkbox-field");
var data_validator_1 = require("hornet-js-core/src/validation/data-validator");
var classNames = require("classnames");
var _ = require("lodash");
var select_field_1 = require("hornet-js-react-components/src/widget/form/select-field");
var buttons_area_1 = require("hornet-js-react-components/src/widget/form/buttons-area");
var event_1 = require("hornet-js-react-components/src/widget/form/event");
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-react-components.widget.form.form");
/**
 * Composant permettant de rendre un formulaire Hornet de manière standardisée
 */
var Form = /** @class */ (function (_super) {
    tslib_1.__extends(Form, _super);
    function Form(props, context) {
        var _this = _super.call(this, props, context) || this;
        var calendarLocale = _this.i18n("calendar");
        if (calendarLocale == null) {
            calendarLocale = {};
        }
        /* Messages génériques */
        /* Configuration locale des calendriers et dates */
        _this.state.calendarLocale = calendarLocale;
        _this.state.customNotif = props.notifId != null;
        _this.state.notifId = props.notifId != null ? props.notifId : "Form-" + (Form.idx++);
        _this.listen(event_1.VALUE_CHANGED_EVENT, function (ev) {
            if (ev.detail.form.id == _this.state.id && _this.state.onFormChange) {
                _this.state.onFormChange();
            }
        });
        return _this;
    }
    // Setters (pas de setter sur defaultValues, car cette propriété sert uniquement lors du montage initial du composant
    Form.prototype.setName = function (value, callback) {
        this.setState({ name: value }, callback);
        return this;
    };
    Form.prototype.setOnSubmit = function (handler, callback) {
        this.setState({ onSubmit: handler }, callback);
        return this;
    };
    Form.prototype.setOnFormChange = function (handler, callback) {
        this.setState({ onFormChange: handler }, callback);
        return this;
    };
    Form.prototype.setIsMandatoryFieldsHidden = function (value, callback) {
        this.setState({ isMandatoryFieldsHidden: value }, callback);
        return this;
    };
    Form.prototype.setSubTitle = function (value, callback) {
        this.setState({ subTitle: value }, callback);
        return this;
    };
    Form.prototype.setText = function (value, callback) {
        this.setState({ text: value }, callback);
        return this;
    };
    Form.prototype.setClassName = function (value, callback) {
        this.setState({ className: value }, callback);
        return this;
    };
    Form.prototype.setMarkRequired = function (value, callback) {
        this.setState({ markRequired: value }, callback);
        /* Propagation de la propriété aux champs Hornet appartenant à ce formulaire */
        this.updateMarkRequiredFields(value);
        return this;
    };
    Form.prototype.setImgFilePath = function (value, callback) {
        this.setState({ imgFilePath: value }, callback);
        /* Propagation de la propriété aux champs Hornet appartenant à ce formulaire */
        this.updateImagFilePathFields(value);
        return this;
    };
    Form.prototype.setSchema = function (value, callback) {
        this.setState({ schema: value }, callback);
        return this;
    };
    Form.prototype.setValidationOptions = function (value, callback) {
        this.setState({ validationOptions: value }, callback);
        return this;
    };
    Form.prototype.setFormMessages = function (value, callback) {
        this.setState({ formMessages: value }, callback);
        return this;
    };
    Form.prototype.setCustomValidators = function (value, callback) {
        this.setState({ customValidators: value }, callback);
        return this;
    };
    Form.prototype.setNotifId = function (value, callback) {
        if (value != null) {
            this.setState({ notifId: value, customNotif: true }, callback);
        }
        else {
            this.setState({ notifId: "Form-" + (Form.idx++), customNotif: false }, callback);
        }
        return this;
    };
    Form.prototype.componentWillUnmount = function () {
        _super.prototype.componentWillUnmount.call(this);
        notification_manager_1.NotificationManager.clean(this.state.notifId, this.state.id);
        if (this.formElement) {
            this.formElement["__component"] = null;
        }
    };
    Form.prototype.componentDidMount = function () {
        _super.prototype.componentDidMount.call(this);
        /* On évite la soumission intempestive du formulaire en cas de clics répétés ou de touche entrée maintenue
         sur le bouton de soumission*/
        this.debouncedValidateAndSubmit = _.debounce(this.validateAndSubmit, 500);
        if (this.state.defaultValues) {
            this.updateFields(this.state.defaultValues);
        }
        if (!this.isOneRequired(this.state.children)) {
            this.setMarkRequired(false);
        }
    };
    /**
     * Met à jour la propriété markRequired sur chacun des champs héritant de AbstractField contenus dans le formulaire
     * @param isMarkRequired valeur à assigner à la propriété 'markRequired'
     * @return ce formulaire
     */
    Form.prototype.updateMarkRequiredFields = function (isMarkRequired) {
        var fields = this.extractFields();
        /* Met à jour l'affichage de chaque champ en cas de readOnly*/
        Object.keys(fields).every(function (key) {
            var field = fields[key];
            if (field instanceof abstract_field_1.AbstractField) {
                field.setMarkRequired(isMarkRequired);
            }
            return true;
        });
        return this;
    };
    /**
     * Met à jour la propriété imgFilePath sur chacun des champs héritant de AbstractField contenus dans le formulaire
     * @param imgFilePath valeur à assigner à la propriété 'imgFilePath'
     * @return ce formulaire
     */
    Form.prototype.updateImagFilePathFields = function (imgFilePath) {
        var fields = this.extractFields();
        Object.keys(fields).every(function (key) {
            var field = fields[key];
            if (field instanceof abstract_field_1.AbstractField) {
                field.setImgFilePath(imgFilePath);
            }
            return true;
        });
        return this;
    };
    /**
     * Met à jour les valeurs courantes des champs du formulaire
     * @param data données du formulaire (clé : nom du champ -> valeur du champ)
     */
    Form.prototype.updateFields = function (data) {
        var fields = this.extractFields();
        this.propagateParentState();
        for (var nameField in fields) {
            var val = _.get(data, nameField);
            if (val != null) {
                if (fields[nameField] instanceof checkbox_field_1.CheckBoxField) {
                    /* Traitement spécifique pour une checkbox : on affecte currentChecked lorsque la valeur est booléenne*/
                    // if (val === true || val === false) {
                    //     fields[name].setCurrentValue("");
                    fields[nameField].setCurrentChecked(val);
                    // } else {
                    //     fields[name].setCurrentValue(val);
                    // }
                }
                else {
                    if (fields[nameField] instanceof select_field_1.SelectField || fields[nameField] instanceof auto_complete_field_1.AutoCompleteField) {
                        if (val instanceof Array) {
                            var choices = [];
                            /** TODO : a deplace dans le composant autocompleteField */
                            if (fields[nameField].state.multiple) {
                                for (var i = 0; i < fields[nameField].state.allChoices.length; i++) {
                                    var choice = fields[nameField].state.allChoices[i];
                                    for (var j = 0; j < val.length; j++) {
                                        if (val[j].toString() == choice["value"]) {
                                            choices.push(choice["value"]);
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                for (var i = 0; i < fields[nameField].state.dataSource.length; i++) {
                                    var choice = fields[nameField].state.dataSource[i];
                                    for (var j = 0; j < val.length; j++) {
                                        if (val[j].toString() == choice[fields[nameField].state.valueKey]) {
                                            choices.push(choice[fields[nameField].state.valueKey]);
                                            break;
                                        }
                                    }
                                }
                            }
                            fields[nameField].setCurrentValue(choices);
                        }
                        else {
                            fields[nameField].setCurrentValue(val);
                        }
                    }
                    else {
                        /* Traitement des champs radio et select en mode readOnly */
                        if ((fields[nameField].state.choices) && (this.state.readOnly || fields[nameField].state.readOnly)) {
                            for (var i = 0; i < fields[nameField].state.dataSource.length; i++) {
                                var choice = fields[nameField].state.dataSource[i];
                                if (val.toString() == choice[fields[nameField].state.valueKey]) {
                                    fields[nameField].setCurrentValue(choice[fields[nameField].state.valueKey]);
                                    break;
                                }
                            }
                        }
                        else {
                            fields[nameField].setCurrentValue(val);
                        }
                    }
                }
            }
            else {
                if (fields[nameField] instanceof checkbox_field_1.CheckBoxField) {
                    fields[nameField].setCurrentChecked(false);
                }
                else {
                    fields[nameField].setCurrentValue(null);
                }
            }
        }
    };
    /**
     * Traitement spécifique des notifications concernant les champs d'autocomplétion
     * @param fields champs du formulaire
     * @param notifs notifications d'erreurs de validation
     */
    Form.prototype.processAutocompleteErrors = function (fields, notifs) {
        var processedNotifs = notifs.getNotifications().map(function (notif) {
            /* Parcours de tous les champs */
            Object.keys(fields).every(function (key) {
                var field = fields[key];
                if (field instanceof auto_complete_field_1.AutoCompleteField) {
                    var autoField = field;
                    /* La notification référence le nom global du champ d'auto-complétion
                     ou bien le champ caché contenant la valeur :
                     on modifie cette référence pour pointer vers le champ de saisie libre */
                    // if (notif.field == autoField.getAttribute("name") ||
                    if (notif.field == autoField.state.name ||
                        notif.field == (autoField.getValueFieldName())) {
                        notif.field = autoField.getFreeTypingFieldName();
                        /* Fin de la boucle de parcours des auto-complete */
                        return false;
                    }
                }
                return true;
            }, this);
            return notif;
        }, this);
        notifs.setNotifications(processedNotifs);
    };
    /**
     * Déclenche les notifications correspondant aux éventuelles erreurs de validation
     * @param errors erreurs de validation de formulaire, éventuellement vides
     */
    Form.prototype.notifyErrors = function (errors) {
        if (errors) {
            var fieldsMessages = this.state.formMessages && this.state.formMessages.fields;
            var genericValidationMessages = this.i18n("form.validation");
            var fields_1 = this.extractFields();
            var notificationsError_1 = form_utils_1.FormUtils.getErrors(errors, fields_1, fieldsMessages, genericValidationMessages);
            /* Post-traitement des notifications concernant les champs d'autocomplétion */
            this.processAutocompleteErrors(fields_1, notificationsError_1);
            /* Met à jour les erreurs affichées par chaque composant champ */
            Object.keys(fields_1).every(function (key) {
                var field = fields_1[key];
                if (field instanceof abstract_field_1.AbstractField) {
                    field.setErrors(notificationsError_1.getNotifications());
                }
                return true;
            });
            /* Emission des notifications */
            notification_manager_1.NotificationManager.notify(this.state.notifId, this.state.id, notificationsError_1);
        }
    };
    /**
     * Transforme les valeurs des champs déclarés avec le format "date-time" dans le schéma de validation :
     * effectue la conversion depuis la locale courante, vers le format ISO 8601. Ceci permet une validation isomorphique
     * côté client comme serveur en utilisant le même schéma, et la conversion automatique en objet Date côté backend REST
     * reste possible.
     * @param schema schéma de validation JSON-Schema
     * @param data données de formualaire
     */
    Form.prototype.transformDatesToISO = function (schema, data) {
        if (schema && schema.properties && data) {
            var propNames = Object.keys(schema.properties);
            var property = void 0, propName = void 0;
            for (var i = 0; i < propNames.length; i++) {
                propName = propNames[i];
                property = schema.properties[propName];
                if (property.type == "object") {
                    /* Appel récursif sur les éventuelles propriétés incluses dans le sous-schéma */
                    this.transformDatesToISO(property, data[propName]);
                }
                else if (property.format == "date-time") {
                    if (data[propName]) {
                        var date = hornet_js_utils_1.Utils.dateUtils.parseInTZ(data[propName], this.state.calendarLocale.dateFormat);
                        if (date) {
                            /* La chaîne de caractères est une date valide pour la locale : on convertit en représentation ISO 8601.*/
                            data[propName] = date.toISOString();
                        }
                        /* Sinon la valeur incorrecte est conservée*/
                    }
                }
            }
        }
    };
    /**
     * Déclenche la validation du formulaire, notifie les erreurs éventuelles et exécute la fonction
     * onSubmit présente dans les propriétés s'il n'y a pas d'erreurs
     *
     */
    Form.prototype.validateAndSubmit = function () {
        if (this.formElement) {
            logger.trace("Validation et envoi du formulaire");
            var data = this.extractData();
            if (this.state.onBeforeSubmit) {
                this.state.onBeforeSubmit(data);
            }
            var options = this.state.validationOptions;
            var schema = data_validator_1.DataValidator.transformRequiredStrings(this.state.schema);
            this.transformDatesToISO(this.state.schema, data);
            var validationRes = new data_validator_1.DataValidator(schema, this.state.customValidators, options).validate(data);
            if (!validationRes.valid) {
                this.notifyErrors(validationRes.errors);
            }
            else {
                this.cleanFormErrors();
                if (this.state.onSubmit) {
                    this.state.onSubmit(data);
                }
            }
        }
    };
    /**
     * Supprime les nofifications d'erreurs et les erreurs associées à chaque champ de ce formulaire
     */
    Form.prototype.cleanFormErrors = function () {
        var fields = this.extractFields();
        for (var fieldName in fields) {
            var field = fields[fieldName];
            if (field instanceof abstract_field_1.AbstractField) {
                field.setErrors(null);
            }
        }
        notification_manager_1.NotificationManager.clean(this.state.notifId, this.state.id);
    };
    /**
     * Met à jour les valeurs courantes des champs du formulaire et
     * supprime les nofifications d'erreurs et les erreurs associées à chaque champ de ce formulaire
     * @param data données du formulaire (clé : nom du champ -> valeur du champ)
     */
    Form.prototype.updateFieldsAndClean = function (data) {
        this.updateFields(data);
        this.cleanFormErrors();
    };
    /**
     * Méthode permettant d'alimenter le bloc Notifications d'erreurs puis de déléguer l'évent au composant parent
     * @param e
     *
     */
    Form.prototype._submitHornetForm = function (e) {
        /* e.preventDefault ne doit pas être 'débouncée', sinon la soumission par défaut du formulaire serait effectuée */
        e.preventDefault();
        this.debouncedValidateAndSubmit();
    };
    /** @override */
    Form.prototype.propagateParentState = function () {
        /* Le composant parent se charge de propager les propriétés readOnly et disabled */
        _super.prototype.propagateParentState.call(this);
        var fields = this.extractFields();
        Object.keys(fields).every(function (key) {
            var field = fields[key];
            if (field instanceof abstract_field_1.AbstractField) {
                field.setMarkRequired(this.state.markRequired);
                field.setImgFilePath(this.state.imgFilePath);
            }
            return true;
        }, this);
    };
    /** @override */
    Form.prototype.extractFields = function () {
        var fields = {};
        if (this.formElement) {
            for (var index = 0; index < this.formElement.elements.length; index++) {
                var item = this.formElement.elements[index];
                if (item["name"]) {
                    if (item["__component"]) {
                        fields[item["name"]] = item["__component"];
                    }
                    else {
                        if (fields[item["name"]]) {
                            fields[item["name"]].addHtmlElement(item);
                        }
                        else {
                            fields[item["name"]] = new dom_adapter_1.DomAdapter();
                            fields[item["name"]].registerHtmlElement(item);
                        }
                    }
                }
            }
        }
        return fields;
    };
    /**
     * Méthode permettant de déterminer si le formulaire dispose d'un champ de type UploadFileField
     * Dans ce cas, on ajoute la propriété ["encType"] = "multipart/form-data" au formulaire
     * @param items
     * @returns {boolean}
     */
    Form.prototype.isMultiPartForm = function (items) {
        var _this = this;
        var isMultiPart = false;
        React.Children.map(items, function (child) {
            if (!isMultiPart) {
                if (child != null) {
                    if (child["props"] && child["props"].children) {
                        isMultiPart = _this.isMultiPartForm(child["props"].children);
                    }
                    if (!isMultiPart && child.type === upload_file_field_1.UploadFileField) {
                        isMultiPart = true;
                    }
                }
            }
        });
        return isMultiPart;
    };
    /**
     * Méthode permettant de déterminer s'il y a au moins un champ requis.
     * @param items
     * @returns {boolean}
     */
    Form.prototype.isOneRequired = function (items) {
        var _this = this;
        var isOneRequired = false;
        React.Children.map(items, function (child) {
            if (!isOneRequired) {
                if (child != null) {
                    if (child["props"] && child["props"].children) {
                        isOneRequired = _this.isOneRequired(child["props"].children);
                    }
                    if (!isOneRequired && child.props && child.props.required == true) {
                        isOneRequired = true;
                    }
                }
            }
        });
        return isOneRequired;
    };
    /**
     * @inheritDoc
     */
    Form.prototype.render = function () {
        var classes = {
            "form": true,
            "clear": true,
            /* Application du style CSS readonly à tout le bloc lorsque tous les champs sont en lecture seule */
            "readonly": this.state.readOnly
        };
        logger.trace("render(), HornetForm ");
        var customNotif = null;
        if (!this.state.customNotif) {
            customNotif = (React.createElement(notification_1.Notification, { id: this.state.notifId }));
        }
        /* La validation de formulaire HTML 5 est désactivée (noValidate="true") :
         on s'appuie uniquement sur la validation à la soumission et on a ainsi un rendu cohérent entre navigateurs. */
        var formProps = {
            id: this.state.id,
            name: this.state.name,
            className: this.state.className,
            method: "post",
            onSubmit: this._submitHornetForm,
            noValidate: true,
            onChange: this.state.onFormChange ? this.state.onFormChange : undefined,
            ref: this.registerForm
        };
        if (this.isMultiPartForm(this.state.children)) {
            formProps["encType"] = "multipart/form-data";
        }
        var textHtmlProps = {
            lang: this.props.textLang ? this.props.textLang : null
        };
        return (React.createElement("section", { className: "form-container" },
            customNotif,
            React.createElement("div", { className: classNames(classes) },
                React.createElement("form", tslib_1.__assign({}, formProps),
                    (this.state.subTitle || this.state.text
                        || (this.state.markRequired && !this.state.isMandatoryFieldsHidden)) ?
                        React.createElement("div", { className: "form-titles" },
                            this.state.subTitle ? React.createElement("h3", { className: "form-soustitre" }, this.state.subTitle) : null,
                            this.state.text ?
                                React.createElement("p", tslib_1.__assign({ className: "form-texte" }, textHtmlProps), this.state.text) : null,
                            this.state.markRequired && !this.state.isMandatoryFieldsHidden ?
                                React.createElement("p", { className: "discret" }, this.i18n("form.fillField")) : null)
                        : null,
                    (this.state.children) ?
                        React.createElement("div", { className: "form-content" },
                            React.createElement("div", null, this.state.children))
                        : null))));
    };
    /**
     * retourne un tableau de bouton pour la validation du formulaire
     * @param children
     * @returns {Array<any>}
     */
    Form.prototype.getButtonsArea = function (children) {
        var tableauButtonsArea = [];
        React.Children.map(children, function (child) {
            if (child.type === buttons_area_1.ButtonsArea) {
                tableauButtonsArea.push(child);
            }
        });
        return tableauButtonsArea;
    };
    Form.idx = 0;
    /** Valeur de propriétés par défaut */
    Form.defaultProps = _.assign(_.cloneDeep(abstract_form_1.AbstractForm.defaultProps), {
        markRequired: true,
        isMandatoryFieldsHidden: false,
        subTitle: null,
        className: "formRecherche",
        customValidators: [],
        validationOptions: data_validator_1.DataValidator.DEFAULT_VALIDATION_OPTIONS
    });
    return Form;
}(abstract_form_1.AbstractForm));
exports.Form = Form;

//# sourceMappingURL=form.js.map
