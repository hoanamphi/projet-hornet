"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * hornet-js-react-components - Ensemble des composants web React de base de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var React = require("react");
var auto_complete_field_1 = require("hornet-js-react-components/src/widget/form/auto-complete-field");
var auto_complete_selector_1 = require("hornet-js-react-components/src/widget/form/auto-complete-selector");
var _ = require("lodash");
var key_codes_1 = require("hornet-js-components/src/event/key-codes");
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-react-components.widget.form.auto-complete-multi-field");
/**
 * Composant d'auto-complétion  a choix multiple.
 */
var AutoCompleteMultiField = /** @class */ (function (_super) {
    tslib_1.__extends(AutoCompleteMultiField, _super);
    function AutoCompleteMultiField(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state.itemSelectedLabel = "";
        _this.state.multiple = true;
        return _this;
    }
    /**
     * @inheritDoc
     * @param {AutoCompleteFieldProps} nextProps
     * @param nextState
     * @param nextContext
     */
    AutoCompleteMultiField.prototype.componentWillUpdate = function (nextProps, nextState, nextContext) {
        _super.prototype.componentWillUpdate.call(this, nextProps, nextState, nextContext);
        if (this.state.delay != nextState.delay) {
            /* Le délai d'appel de l'action a changé : on doit donc refaire ici l'encaspulation avec _.throttle */
            this._throttledTriggerAction = _.throttle(this.triggerAction, nextState.delay);
        }
    };
    /**
     * @inheritDoc AutoCompleteField
     */
    AutoCompleteMultiField.prototype.componentDidMount = function () {
        _super.prototype.componentDidMount.call(this);
        if (this.textInput && this.textInput.placeholder == "") {
            this.textInput.placeholder = this.state.itemSelectedLabel.replace('{count}', 0) || this.i18n("form.autoCompleteField.selectedItem", { "count": 0 });
        }
    };
    /**
     * ferme la liste de choix de l'autocomplete lors d'un clic en dehors
     */
    AutoCompleteMultiField.prototype.eventClickListener = function () {
        var focus = document.activeElement;
        var container = this.autocompleteContainer;
        if (container && focus && focus != container) {
            if (!container.contains(focus)) {
                this.hideChoices();
            }
        }
    };
    /**
     * Génère le rendu spécifique du champ
     * @returns {any}
     */
    AutoCompleteMultiField.prototype.renderWidget = function () {
        var _this = this;
        logger.trace("auto-complete multiple render");
        var shouldShow = this.shouldShowChoices();
        var hasError = this.hasErrors() ? " has-error" : "";
        var className = " autocomplete-content" + hasError;
        if (this.state.className) {
            className += " " + this.state.className;
        }
        var htmlProps = this.getHtmlProps();
        htmlProps = _.assign(htmlProps, {
            "onKeyDown": this.handleOnKeyDown,
            "onFocus": this.handleOnFocus,
            "onBlur": this.handleOnBlur,
            "onDoubleClick": this.handleOnFocus,
            "onClick": this.handleOnFocus,
            "onChange": this.handleChangeTextInput,
            "autoComplete": "off",
            "aria-autocomplete": "list",
            "aria-expanded": shouldShow,
            "aria-owns": this.state.ariaSelectorId,
            "aria-activedescendant": shouldShow ? this.state.ariaSelectorId + "_" + this.state.selectedIndex : undefined,
            "aria-multiselectable": true,
            "id": this.state.id ? this.state.id : this.getFreeTypingFieldName(),
            "type": "text",
            "name": this.getFreeTypingFieldName(),
            "className": className
        });
        var classNameContainer = "autocomplete-container";
        //if (this.getTotalSelectedItems() != 0 && this.state.listDefaultValue && this.state.listDefaultValue.length > 0) {
        if (this.getTotalSelectedItems() != 0 && this.textInput && this.textInput.value != "" && this.textInput.value.length > 0) {
            classNameContainer += " badge-autocomplete-selected-items-before";
        }
        /* Le champ caché contient l'identifiant de l'élément sélectionné. C'est cet identifiant qui est ensuite
         utilisé par les actions. */
        return (React.createElement("div", { className: classNameContainer, "data-badge": this.getTotalSelectedItems(), ref: function (elt) { return _this.autocompleteContainer = elt; } },
            React.createElement("input", { type: "hidden", name: this.getValueFieldName(), ref: this.registerHiddenInput, "data-multiple": true }),
            React.createElement("input", tslib_1.__assign({}, htmlProps, { ref: this.registerTextInput, "data-multiple": true, readOnly: !this.props.writable || this.state.readOnly, "data-writable": this.props.writable })),
            React.createElement(auto_complete_selector_1.AutoCompleteSelector, { ref: "selector", choices: this.state.choices, onOptionSelected: this.onListWidgetSelected, selectorId: this.state.ariaSelectorId, maxHeight: this.props.maxHeight, showComponent: shouldShow, isMultiple: true, choicesSelected: this.state.listDefaultValue, autoCompleteState: this.autoCompleteState, disabled: this.state.disabled || this.state.readOnly, noResultLabel: this.state.noResultLabel })));
    };
    /**
     * navigation dans les choix
     * @param {number} delta
     */
    AutoCompleteMultiField.prototype.navigateInChoices = function (delta) {
        var _this = this;
        var newIndex = this.state.selectedIndex === null ? (delta === 1 ? 0 : delta) : this.state.selectedIndex + delta;
        var choicesLength = this.state.choices ? this.state.choices.length : 0;
        if (newIndex < 0) {
            //On va à la fin
            newIndex += choicesLength;
        }
        else if (newIndex >= choicesLength) {
            //On retourne au début
            newIndex = 0;
        }
        //on sélectionne le choix sur lequel on se trouve
        this.setState({ selectedIndex: newIndex }, function () {
            _this.selectCurrentIndex();
            _this.autoCompleteState.setFocusOn(_this.state.selectedIndex, _this.hiddenInput.value, newIndex);
        });
        // On s'assure de l'affichage de la liste déroulante
        if (this.state.shouldShowChoices) {
            this.showChoices();
        }
        ;
    };
    /**
     * Fonction appelée lors d'un appui de touche sur le champ de saisie libre
     * @param e évènement
     * @protected
     */
    AutoCompleteMultiField.prototype.handleOnKeyDown = function (e) {
        /* L'attribut DOM onKeyDown est éventuellement aussi renseigné sur le composant auto-complete */
        if (this.state.onKeyDown) {
            this.state.onKeyDown(event);
        }
        var key = e.keyCode;
        var shouldShow = this.state.shouldShowChoices === true;
        if (key == key_codes_1.KeyCodes.DOWN_ARROW) {
            if (this.isValidText(this.textInput.value)) {
                if (e.altKey) {
                    this.handleOnFocus(e);
                }
                else {
                    this.navigateInChoices(1);
                }
            }
            else {
                if (e.altKey) {
                    this.handleOnFocus(e);
                }
                else {
                    this.navigateInChoices(1);
                }
            }
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.UP_ARROW) {
            if (e.altKey) {
                this.hideChoices();
            }
            else {
                this.navigateInChoices(-1);
            }
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.ESCAPE) {
            this.hideChoices();
            e.preventDefault();
        }
        else if (e.keyCode == key_codes_1.KeyCodes.SPACEBAR && !this.state.writable) {
            if (shouldShow && !this.state.readOnly && !this.state.disabled) {
                var indexSelected_1 = this.autoCompleteState.choiceFocused;
                var listDefaultValue = (this.state.listDefaultValue) ? _.cloneDeep(this.state.listDefaultValue) : [];
                var itemSelected_1;
                this.state.choices.map(function (item, index) {
                    if (indexSelected_1 === index) {
                        itemSelected_1 = item;
                    }
                });
                if (itemSelected_1) {
                    this.computeCurrentValues(itemSelected_1.value);
                }
            }
            e.preventDefault();
        }
        else if (e.keyCode == key_codes_1.KeyCodes.ENTER && this.state.writable) {
            if (shouldShow && !this.state.readOnly && !this.state.disabled) {
                var indexSelected_2 = this.autoCompleteState.choiceFocused;
                var listDefaultValue = (this.state.listDefaultValue) ? _.cloneDeep(this.state.listDefaultValue) : [];
                var itemSelected_2;
                this.state.choices.map(function (item, index) {
                    if (indexSelected_2 === index) {
                        itemSelected_2 = item;
                    }
                });
                if (itemSelected_2) {
                    this.computeCurrentValues(itemSelected_2.value);
                }
            }
            else if (!shouldShow) {
                this.showChoices();
            }
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.TAB) {
            this.selectCurrentIndex();
            this.hideChoices();
        }
        else if (key == key_codes_1.KeyCodes.HOME) {
            if (shouldShow) {
                this.state.selectedIndex = null;
                this.navigateInChoices(1);
            }
            else {
                this.state.selectedIndex = 0;
                this.selectCurrentIndex();
                this.hideChoices();
            }
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.END) {
            if (shouldShow) {
                this.state.selectedIndex = null;
                this.navigateInChoices(-1);
            }
            else {
                this.state.selectedIndex = this.state.choices.length - 1;
                this.selectCurrentIndex();
                this.hideChoices();
            }
            e.preventDefault();
        }
        // Action lorsqu'on appuie la touche controle
        if (e.ctrlKey) {
            if (e.keyCode == 65) {
                logger.trace(" Autocomplete multiple ctrl+A ");
                var listDefaultValue_1 = (this.state.listDefaultValue && this.state.listDefaultValue instanceof Array) ? _.cloneDeep(this.state.listDefaultValue) : [];
                if (listDefaultValue_1.length == this.refs.selector.props.choices.length) {
                    listDefaultValue_1 = [];
                    this.changeSelectedChoice();
                    this.setState({ listDefaultValue: [] });
                }
                else {
                    if (listDefaultValue_1.length < this.refs.selector.props.choices.length) {
                        listDefaultValue_1 = [];
                    }
                    this.refs.selector.props.choices.map(function (item) {
                        if (typeof (listDefaultValue_1.push) == "function") {
                            listDefaultValue_1.push(item.value);
                        }
                    });
                    this.setState({ listDefaultValue: listDefaultValue_1 });
                    this.changeSelectedChoice();
                }
                this.setCurrentValue(listDefaultValue_1);
            }
        }
    };
    /**
     * Fonction déclenchée sur une modification du champ de saisie libre
     * @param event
     */
    AutoCompleteMultiField.prototype.handleChangeTextInput = function (event) {
        var _this = this;
        logger.trace("auto-complete multiple handleChangeTextInput");
        /* L'attribut DOM onChange est éventuellement aussi renseigné sur le composant auto-complete */
        if (this.state.onChange) {
            this.state.onChange(event);
        }
        var newText = this.getCurrentText();
        if (this.refs.selector) {
            this.refs.selector.setCurrentTypedText(newText);
        }
        /* Le texte a changé donc on réinitialise la valeur */
        this.resetSelectedValue();
        if (this.isValidText(newText)) {
            logger.trace("auto-complete : prise en compte du texte saisi : ", newText);
            this._throttledTriggerAction(newText);
        }
        else {
            this.hideChoices();
        }
        if (this.state.choices[0] && this.state.choices.length === 1 && _.deburr(newText).toLowerCase() == _.deburr(this.state.choices[0].text).toLowerCase()) {
            this.changeSelectedChoice();
        }
        if (newText.length == 0) {
            this.setChoices(this.state.allChoices, function () {
                if (_this.state.allChoices.length > 0) {
                    _this.showChoices();
                }
            });
        }
        else {
            this.forceUpdate();
        }
    };
    /**
     * créer la liste des values
     * @param value
     */
    AutoCompleteMultiField.prototype.computeCurrentValues = function (value) {
        var res;
        if (value instanceof Array) {
            res = value;
        }
        else {
            var listDefaultValue = (this.state.listDefaultValue && this.state.listDefaultValue instanceof Array) ? _.cloneDeep(this.state.listDefaultValue) : [];
            if (value) {
                var index = listDefaultValue.indexOf(value);
                if (index !== -1) {
                    listDefaultValue.splice(index, 1);
                }
                else {
                    listDefaultValue.push(value);
                }
            }
            else {
                listDefaultValue = [];
            }
            res = listDefaultValue;
        }
        this.setState({ listDefaultValue: res });
        return this.setCurrentValue(res);
    };
    /**
     * set la value
     * @param value
     */
    AutoCompleteMultiField.prototype.setCurrentValue = function (value) {
        var _this = this;
        _super.prototype.setCurrentValue.call(this, value);
        if (this.textInput) {
            this.textInput.placeholder = this.state.itemSelectedLabel.replace('{count}', value ? value.length : 0) || this.i18n("form.autoCompleteField.selectedItem", { "count": value ? value.length : 0 });
        }
        this.changeSelectedChoice();
        if (value) {
            var res = value.map(function (item) {
                return _.find(_this.props.dataSource.results, { value: item });
            });
            this.props.dataSource.select(res);
        }
        else {
            this.props.dataSource.selectClean(true);
        }
        return this;
    };
    /**
     * @inheritDoc
     * Fonction appelée lorsque l'utilisateur a choisi un élément de la liste de choix pour nettoyer le currentText du selector
     * Ici on diffère du normal, car cette gestion est propre à ce dernier.
     */
    AutoCompleteMultiField.prototype.changeSelectedChoice = function (choice) {
        if (this.refs.selector) {
            this.refs.selector.setCurrentTypedText("");
        }
    };
    /**
     * ajout d'un listener sur les clic
     */
    AutoCompleteMultiField.prototype.showChoices = function () {
        var _this = this;
        if (this.state.shouldShowChoices !== true && this.state.focused) {
            if (this.isValidText(this.textInput.value) || this.textInput.value.length == 0 || !this.props.writable || this.state.readOnly || this.state.disabled) {
                this.setState({ shouldShowChoices: true }, function () {
                    window.addEventListener("click", _this.eventClickListener);
                });
            }
        }
    };
    /**
     * suppression du listener sur les clic
     */
    AutoCompleteMultiField.prototype.hideChoices = function () {
        var _this = this;
        if (this.state.shouldShowChoices !== false) {
            this.setState({ shouldShowChoices: false }, function () {
                window.removeEventListener("click", _this.eventClickListener);
            });
        }
    };
    /**
     * Gestion de l'évènement onFocus pour le champ de saisie libre.
     * @param event
     */
    AutoCompleteMultiField.prototype.handleOnFocus = function (event) {
        var _this = this;
        if (this.state.onSelected) {
            this.hideChoices();
        }
        this.typedValueOnFocus = this.getCurrentText();
        this.state.focused = true;
        this.showChoices();
        /* L'attribut DOM onBlur est éventuellement aussi renseigné sur le composant auto-complete */
        if (this.state.onFocus) {
            this.state.onFocus(event);
        }
        if (this.state.allChoices) {
            if (this.isValidText(this.typedValueOnFocus)) {
                logger.trace("auto-complete : prise en compte du texte présent au focus : ", this.typedValueOnFocus);
                this._throttledTriggerAction(this.typedValueOnFocus);
                this.changeSelectedChoiceWhenOneChoice(this.typedValueOnFocus);
            }
            else {
                this.setChoices(this.state.allChoices, function () {
                    if (_this.state.allChoices.length > 0) {
                        _this.showChoices();
                    }
                });
            }
        }
        else {
            this.showChoices();
        }
        if (!this.hiddenInput || this.hiddenInput.value.length == 0) {
            this.clearFilterData();
        }
        else {
            this.autoCompleteState.setFocusOn(this.state.selectedIndex, this.hiddenInput.value, null);
        }
    };
    /**
     * Fonction déclenchée lorsque le champ de saisie libre perd le focus
     * @param event
     */
    AutoCompleteMultiField.prototype.handleOnBlur = function (event) {
        if (this.state.onSelected) {
            this.state.onSelected = false;
        }
        else {
            this.state.focused = false;
            /* L'attribut DOM onBlur est éventuellement aussi renseigné sur ce composant auto-complete */
            if (this.state.onBlur) {
                this.state.onBlur(event);
            }
            var currentText_1 = this.getCurrentText();
            if (this.state.allChoices) {
                this.state.allChoices.filter(function (choice) {
                    var res = false;
                    if (!choice.text) {
                        res = choice.text.toLowerCase() === currentText_1.toLowerCase();
                    }
                    return res;
                });
            }
            this.hideChoices();
            this.isUpdated = false;
        }
        if (this.getTotalSelectedItems() == 0 || this.props.cleanFilterOnBlur) {
            //supprime la saisie pour voir le placeholder et reinitialisation du selecteur,
            // equivalent this.resetSelectedText(), mais ne provoque pas de nouveau rendu
            this.textInput.value = "";
            this.refs.selector.state.currentTypedText = "";
        }
        /* if (this.refs.selector) {
             (this.refs.selector as AutoCompleteSelector).state.currentTypedText = "";
         }
         let value = this.state.listDefaultValue;
         if (this.textInput) {
             this.textInput.placeholder = this.state.itemSelectedLabel.replace('{count}', value ? value.length : "") || this.i18n("form.autoCompleteField.selectedItem", {"count": value ? value.length : ""});
         }*/
    };
    /**
     * Fonction appelée lorsque l'utilisateur clique sur un item de la liste des valeurs possibles
     * @param event
     */
    AutoCompleteMultiField.prototype.getTotalSelectedItems = function () {
        return this.state.currentValue ? this.state.currentValue.length : 0;
    };
    /**
     * Fonction appelée lorsque l'utilisateur clique sur un item de la liste des valeurs possibles
     * @param event
     */
    AutoCompleteMultiField.prototype.onListWidgetSelected = function (event, choice) {
        logger.trace("Selection Multiple click");
        var selectedValue = choice.value;
        if (event.target !== event.currentTarget) {
            this.state.onSelected = true;
        }
        this.computeCurrentValues(selectedValue);
        event.nativeEvent.preventDefault();
        event.nativeEvent.stopPropagation();
        event.nativeEvent.stopImmediatePropagation();
    };
    return AutoCompleteMultiField;
}(auto_complete_field_1.AutoCompleteField));
exports.AutoCompleteMultiField = AutoCompleteMultiField;

//# sourceMappingURL=auto-complete-multi-field.js.map
