"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * hornet-js-core - Ensemble des composants qui forment le coeur de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var director_1 = require("director");
var abstract_routes_1 = require("hornet-js-core/src/routes/abstract-routes");
var lazy_class_loader_1 = require("hornet-js-utils/src/lazy-class-loader");
var _ = require("lodash");
var Http = require("http");
var not_found_error_1 = require("hornet-js-utils/src/exception/not-found-error");
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-core.routes.router-server");
var RouterServer = /** @class */ (function () {
    function RouterServer(appRoutes, lazyRoutesClassResolver, routesPaths, routesDataContext) {
        if (routesDataContext === void 0) { routesDataContext = "/services"; }
        this.dataRoutes = {};
        this.pageRoutes = {};
        this.dataContext = "/services";
        this.appRoutes = appRoutes;
        this.lazyRoutesClassResolver = lazyRoutesClassResolver || appRoutes.getDefaultRouteLoader(routesPaths);
        this.dataContext = routesDataContext;
        this.computeRoutes();
        logger.trace("routes chargées (PAGE) :", this.pageRoutes);
        logger.trace("routes chargées (DATA) :", this.dataRoutes);
        this.directorData = new director_1.http.Router(this.dataRoutes).configure({ recurse: false, async: true });
        this.directorPage = new director_1.http.Router(this.pageRoutes).configure({ recurse: false, async: true });
        /** GESTION DES PUBLIC_ROUTES **/
        // les PUBLIC_ROUTES ne sont pas interprétées comme telles, car la méthode isAuthenticated (PASSPORT) est exécutée avant l'instanciation de DIRECTOR
        // La méthode isAuthenticated de passport est donc surchargée dans le cas d'une PUBLIC_ROUTE
        var req = Http.IncomingMessage.prototype;
        if (!req.__oldIsAuthenticated__) {
            req.__oldIsAuthenticated__ = req.isAuthenticated;
        }
        req.isAuthenticated = function () {
            var routesInfos = global.routesInfos;
            var _req = this;
            var isAuthenticated = false;
            var directorPage = new director_1.http.Router(routesInfos).configure({ recurse: false, async: true });
            var fns = directorPage.traverse(_req.method.toLowerCase(), _req.url, directorPage.routes, '', function (route) {
                if (Array.isArray(route.authorization) && route.authorization.length == 0) {
                    isAuthenticated = true;
                }
                else {
                    isAuthenticated = _req.__oldIsAuthenticated__();
                }
            });
            if (!fns) {
                this.unknowedRoute = true;
                return _req.__oldIsAuthenticated__();
            }
            return isAuthenticated;
        };
    }
    /**
     * Méthode utilisée par la partie serveur pour initialiser le routeur.
     * Note: Fourni un middleware Express
     */
    RouterServer.prototype.dataMiddleware = function () {
        var directorData = this.directorData;
        return function middleware(req, res, next) {
            if (hornet_js_utils_1.Utils.getCls("hornet.routeType") !== abstract_routes_1.RouteType.DATA)
                return next();
            directorData.dispatch(req, res, function (err) {
                if (err) {
                    if (err.status && err.status == 404) {
                        err = new not_found_error_1.NotFoundError({ errorMessage: err.message }, err);
                    }
                    next(err);
                }
                else
                    next();
            });
        };
    };
    RouterServer.prototype.pageMiddleware = function () {
        var directorPage = this.directorPage;
        return function middleware(req, res, next) {
            if (hornet_js_utils_1.Utils.getCls("hornet.routeType") !== abstract_routes_1.RouteType.PAGE) {
                return next();
            }
            directorPage.dispatch(req, res, function (err) {
                if (err) {
                    if (err.status && err.status == 404) {
                        err = new not_found_error_1.NotFoundError({ errorMessage: err.message }, err);
                    }
                    next(err);
                }
                else
                    next();
            });
        };
    };
    RouterServer.prototype.computeRoutes = function (routesObj, prefix) {
        if (routesObj === void 0) { routesObj = this.appRoutes; }
        if (prefix === void 0) { prefix = ""; }
        this.parseRoutes(routesObj.getPageRoutes(), this.pageRoutes, prefix);
        this.parseRoutes(routesObj.getDataRoutes(), this.dataRoutes, prefix);
        this.parseLazyRoutes(routesObj.getLazyRoutes(), prefix);
        this.parseSubRoutes(routesObj.getSubRoutes(), prefix);
        this.computeAuthorizationsRoutes(routesObj.getPageRoutes(), routesObj.getDataRoutes(), prefix);
    };
    RouterServer.prototype.computeAuthorizationsRoutes = function (pageRoutes, dataRoutes, prefix) {
        var objPage = {}, objData = {};
        for (var key in pageRoutes) {
            objPage[prefix + key] = pageRoutes[key];
        }
        for (var key in dataRoutes) {
            objData[this.dataContext + prefix + key] = dataRoutes[key];
        }
        global.routesInfos = _.merge(global.routesInfos, objPage, objData);
    };
    RouterServer.prototype.parseRoutes = function (declaredRoutes, internalObj, prefix) {
        for (var path in declaredRoutes) {
            for (var method in declaredRoutes[path]) {
                var uri = prefix + path;
                if (!internalObj[uri]) {
                    internalObj[uri] = {};
                }
                if (internalObj[uri][method]) {
                    throw new Error("Route duppliquée : ('" + uri + "' <" + method + ">)");
                }
                internalObj[uri][method] = this.buildRouteHandler(declaredRoutes, path, method);
            }
        }
    };
    RouterServer.prototype.buildRouteHandler = function (declaredRoutes, path, method) {
        var _this = this;
        return function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            var done = params.pop();
            try {
                _this.handleRoute(declaredRoutes[path][method].authorization, declaredRoutes[path][method].handler, method, params);
                done();
            }
            catch (err) {
                done(err);
            }
        };
    };
    RouterServer.prototype.parseLazyRoutes = function (lazyRoutes, prefix) {
        for (var lazy in lazyRoutes) {
            var lazyClass = this.lazyRoutesClassResolver(lazyRoutes[lazy]);
            var routesClass = lazy_class_loader_1.LazyClassLoader.load(lazyClass);
            this.computeRoutes(new routesClass(), prefix + lazy);
        }
    };
    RouterServer.prototype.handleRoute = function (authorization, handler, method, params) {
        hornet_js_utils_1.Utils.setCls("hornet.routeAuthorization", authorization);
        hornet_js_utils_1.Utils.setCls("hornet.routeInfos", handler.apply(null, params));
    };
    RouterServer.prototype.parseSubRoutes = function (subRoutes, prefix) {
        for (var sub in subRoutes) {
            var routesClass = lazy_class_loader_1.LazyClassLoader.load(subRoutes[sub]);
            this.computeRoutes(new routesClass(), prefix + sub);
        }
    };
    return RouterServer;
}());
exports.RouterServer = RouterServer;

//# sourceMappingURL=router-server.js.map
