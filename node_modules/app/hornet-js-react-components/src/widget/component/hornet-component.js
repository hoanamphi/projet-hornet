"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * hornet-js-react-components - Ensemble des composants web React de base de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var React = require("react");
var _ = require("lodash");
var hornet_event_1 = require("hornet-js-core/src/event/hornet-event");
var hornet_component_errors_1 = require("hornet-js-core/src/component/hornet-component-errors");
var i18n_utils_1 = require("hornet-js-utils/src/i18n-utils");
var pathToRegexp = require('path-to-regexp');
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-react-components.widget.component.hornet-component");
var Alignment;
(function (Alignment) {
    Alignment[Alignment["CENTER"] = 0] = "CENTER";
    Alignment[Alignment["LEFT"] = 1] = "LEFT";
    Alignment[Alignment["RIGHT"] = 2] = "RIGHT";
})(Alignment = exports.Alignment || (exports.Alignment = {}));
/**
 * Classe parente des composants graphiques Hornet basés sur React.
 */
var HornetComponent = /** @class */ (function (_super) {
    tslib_1.__extends(HornetComponent, _super);
    function HornetComponent(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.rendering = false;
        _this.hasError = false;
        _this.mounted = false;
        /* Chargement des données USer */
        _this.user = hornet_js_utils_1.Utils.getCls("hornet.user");
        _this.state = {};
        _this.autobinding();
        if (!hornet_js_utils_1.Utils.isServer)
            _this.errorManagement();
        /* On alimente automatiquement l'état interne du composant avec toutes les propriétés */
        _this.copyInitialPropsToState(_this.props, _this.state);
        return _this;
    }
    HornetComponent.prototype.componentWillMount = function () {
        // gestion de l'injection automatique des instances de composants avec props "var=()=>{}"
        if (!hornet_js_utils_1.Utils.isServer) {
            if (!_.isUndefined(this.props["var"]) && _.isFunction(this.props["var"])) {
                this.props["var"](this);
            }
        }
    };
    HornetComponent.prototype.componentDidMount = function () {
        this.mounted = true;
    };
    HornetComponent.prototype.componentWillUpdate = function (nextProps, nextState, nextContext) {
    };
    HornetComponent.prototype.componentDidUpdate = function (prevProps, prevState, prevContext) {
    };
    HornetComponent.prototype.componentWillUnmount = function () {
        if (!_.isUndefined(this.props["var"]) && _.isFunction(this.props["var"])) {
            this.props["var"](null);
        }
        this.mounted = false;
    };
    /**
     * Met à jour l'état interne avec les nouvelles propriétés
     * @param nextProps nouvelles propriétés
     * @param nextContext nouveau contexte
     */
    HornetComponent.prototype.componentWillReceiveProps = function (nextProps, nextContext) {
        for (var key in nextProps) {
            /* On doit s'assurer que chaque propriété a effectivement changé, car componentWillReceiveProps peut aussi
             * être appelée alors qu'aucune propriété n'a changé
             * (cf.http://facebook.github.io/react/blog/2016/01/08/A-implies-B-does-not-imply-B-implies-A.html)
             *
             * On ne veut pas dans ce cas écraser l'état avec l'ancienne propriété. En effet l'état peut avaoir été modifié
             * via un setter alors que la propriété utilisée initialement pour le constructeur n'a pas changé.*/
            if (!_.isEqual(this.props[key], nextProps[key])) {
                /* On se base sur le 'setter' portant le même nom que la propriété */
                var setterName = _.camelCase("set " + (key));
                if (this[setterName]) {
                    this[setterName](nextProps[key]);
                }
                else {
                    var state = {};
                    state[key] = nextProps[key];
                    this.setState(state);
                }
            }
        }
    };
    /**
     * A surcharger éventuellement.
     * @return {boolean} true lorsque toutes les fonctions du composant doivent être encapsulées en s'appuyant
     * sur le gestionnaire d'erreurs (getErrorHandler()) et le composant d'affichage erreur (getErrorComponent()).
     */
    HornetComponent.prototype.isErrorManaged = function () {
        return HornetComponent.ERROR_MANAGED;
    };
    /**
     * A surcharger éventuellement.
     * @return {Class<HornetPage<any, any>>} la page à afficher en cas d'erreur
     */
    HornetComponent.prototype.getErrorComponent = function () {
        return HornetComponent.ERROR_COMPONENT;
    };
    /**
     * A surcharger éventuellement.
     * @return {HornetComponentErrorHandler} la fonction implémentant le comportement à adopter en cas d'erreur
     */
    HornetComponent.prototype.getErrorHandler = function () {
        return hornet_component_errors_1.DEFAULT_ERROR_HANDLER;
    };
    HornetComponent.prototype.copyInitialPropsToState = function (props, state) {
        for (var i in props) {
            state[i] = props[i];
        }
    };
    HornetComponent.prototype.autobinding = function () {
        var blacklist = { constructor: 1, errorManagement: 1, wrapMethod: 1 };
        for (var fn in this) {
            if (_.isFunction(this[fn]) && !(fn in blacklist)) {
                this[fn] = this[fn]["bind"](this);
            }
        }
    };
    /**
     * Si la gestion des erreurs est activée, encapsule toutes les fonctions de ce composant avec une gestion d'erreur
     * commune.
     */
    HornetComponent.prototype.errorManagement = function () {
        /* Fonctions à ne pas encapsuler */
        var blacklist = { constructor: 1, errorManagement: 1, wrapMethod: 1 };
        if (this.isErrorManaged()) {
            for (var fn in this) {
                if (_.isFunction(this[fn]) && !(fn in blacklist)) {
                    //this.wrapMethod(fn);
                }
            }
        }
    };
    /**
     * Permet d'écouter un évènement
     * @param event
     * @param callback
     * @param capture
     */
    HornetComponent.prototype.listen = function (event, callback, capture) {
        if (capture === void 0) { capture = true; }
        if (!hornet_js_utils_1.Utils.isServer) {
            hornet_event_1.listenHornetEvent(event, callback, capture);
        }
    };
    /**
     * Permet de n'écouter qu'une seule foix un évènement
     * @param event
     * @param callback
     * @param capture
     */
    HornetComponent.prototype.listenOnce = function (event, callback, capture) {
        if (capture === void 0) { capture = true; }
        if (!hornet_js_utils_1.Utils.isServer) {
            hornet_event_1.listenOnceHornetEvent(event, callback, capture);
        }
    };
    /**
     * Permet d'émettre un évènement
     * @param event
     * @param eventOptions
     */
    HornetComponent.prototype.fire = function (event, eventOptions) {
        if (eventOptions === void 0) { eventOptions = {}; }
        hornet_event_1.fireHornetEvent(event, eventOptions);
    };
    /**
     * Permet de supprimer un évènement
     * @param event
     * @param callback
     * @param capture
     */
    HornetComponent.prototype.remove = function (event, callback, capture) {
        if (capture === void 0) { capture = true; }
        hornet_event_1.removeHornetEvent(event, callback, capture);
    };
    /**
     * Méthode permettant d'enrober un composant
     * @param method
     */
    HornetComponent.prototype.wrapMethod = function (method) {
        var unwrapped = this[method];
        var self = this;
        self[method] = function () {
            try {
                if (method == "render")
                    self.rendering = true;
                return unwrapped.apply(undefined, arguments);
            }
            catch (e) {
                if (!e["hasBeenReported"] && (!self.rendering || method == "render")) {
                    var errorReport = {
                        componentName: self.constructor["name"],
                        method: method,
                        methodArguments: arguments,
                        props: self.props,
                        state: self.state,
                        error: e
                    };
                    e["hasBeenReported"] = true;
                    self.getErrorHandler()(errorReport, self.getErrorComponent());
                }
                // cas de la méthode "render" pour laquelle il faut au moins renvoyer null
                // pour ne pas corrompre React
                if (method == "render") {
                    self.hasError = true;
                    return null;
                }
                else if (!e["hasBeenThrown"]) {
                    e["hasBeenThrown"] = true;
                    throw e;
                }
            }
            finally {
                if (method == "render")
                    self.rendering = false;
            }
        };
    };
    /**
     * Retourne les éléments enfants d'un composant du type passé en paramètre
     * @param ComponentType
     * @returns {Array}
     */
    HornetComponent.prototype.getChildrenOf = function (ComponentType) {
        var children = [];
        React.Children.map(this.props.children, function (child) {
            if (child.type === ComponentType) {
                if (child.props.children) {
                    if (Array.isArray(child.props.children)) {
                        children = child.props.children;
                    }
                    else {
                        children.push(child.props.children);
                    }
                }
            }
        });
        return children.filter(function (element) { return (element != null && element); });
    };
    /**
     * Retourne les éléments enfants d'un composant du type passé en paramètre
     * @param ComponentType
     * @returns {Array}
     */
    HornetComponent.getChildrenFrom = function (parent, componentType) {
        var children = [];
        React.Children.map(parent.props.children, function (child) {
            if (child.type === componentType) {
                if (Array.isArray(child.props.children)) {
                    children = child.props.children;
                }
                else {
                    children.push(child.props.children);
                }
            }
        });
        return children;
    };
    /**
     * Retourne les éléments enfants d'un composant du type passé en paramètre
     * @param ComponentType
     * @returns {Array}
     */
    HornetComponent.prototype.getComponentBy = function (ComponentType) {
        var children;
        React.Children.map(this.props.children, function (child) {
            if (child.type === ComponentType) {
                children = child;
            }
        });
        return children;
    };
    /**
     * Retourne les éléments enfants d'un composant du type passé en paramètre
     * @param ComponentType
     * @returns {Array}
     */
    HornetComponent.getComponentFromParentBy = function (parent, ComponentType) {
        var children;
        React.Children.map(parent.props.children, function (child) {
            if (child.type === ComponentType) {
                children = child;
            }
        });
        return children;
    };
    /**
     * Retourne les éléments enfants d'un composant du type passé en paramètre
     * @param ComponentType
     * @returns {Array}
     */
    HornetComponent.prototype.getComponentsBy = function (ComponentType) {
        var children = [];
        React.Children.map(this.props.children, function (child) {
            if (child.type === ComponentType) {
                children.push(child);
            }
        });
        return children;
    };
    /***
     * Méthode déterminant si un des enfant dont le parent est de type Component est de type ComponentType
     * @param Component: composant dont les enfants sont à rechercher
     * @param ComponentType: type de composant à rechercher
     * @returns {boolean}
     */
    HornetComponent.prototype.hasChildrenOfComponentTypeOf = function (Component, ComponentType) {
        var elements = this.getChildrenOf(Component);
        var nbMax = elements.length;
        for (var i = 0; i < nbMax; i++) {
            if (elements[i] && elements[i].type === ComponentType) {
                return true;
            }
        }
        return false;
    };
    /**
     * Wrap un composant avec de nouvelles props pour eviter le cloneElement
     * @param {HornetComponent} ComponentToWrap composant à wrapper
     * @param {Object} otherProps nouvelle props à ajouter
     */
    HornetComponent.prototype.wrap = function (ComponentToWrap, otherProps, thisProps) {
        if (thisProps === void 0) { thisProps = this.props; }
        var myProps = {};
        this.copyInitialPropsToState(thisProps, myProps);
        this.copyInitialPropsToState(otherProps, myProps);
        var elt = React.createElement(ComponentToWrap, myProps, thisProps.children);
        return elt;
    };
    /**
     * Wrap un composant avec de nouvelles props pour eviter le cloneElement
     * @param {HornetComponent} ComponentToWrap composant à wrapper
     * @param {HornetComponent} componentProps props du composant à wrapper
     * @param {Object} otherProps nouvelle props à ajouter
     */
    HornetComponent.wrap = function (ComponentToWrap, hornetComponentContext, componentProps, otherProps) {
        var WrapComponent = /** @class */ (function (_super) {
            tslib_1.__extends(WrapComponent, _super);
            function WrapComponent(props, context) {
                var _this = _super.call(this, props, context) || this;
                _this.componentWillUnmount.bind(_this.getThisBind());
                _this.componentWillMount.bind(_this.getThisBind());
                return _this;
            }
            WrapComponent.prototype.render = function () {
                return (React.createElement(ComponentToWrap, tslib_1.__assign({}, componentProps, otherProps), componentProps.children));
            };
            WrapComponent.prototype.setState = function () {
                this.componentToWrap.setState(arguments);
            };
            WrapComponent.prototype.getThisBind = function () {
                if (hornetComponentContext.getThisBind) {
                    return hornetComponentContext.getThisBind();
                }
                return hornetComponentContext;
            };
            return WrapComponent;
        }(HornetComponent));
        WrapComponent.defaultProps = ComponentToWrap.defaultProps || {};
        if (componentProps.var) {
            WrapComponent.defaultProps.var = componentProps.var;
        }
        if (componentProps.ref) {
            WrapComponent.defaultProps.ref = componentProps.ref;
        }
        // on retourne notre wrapper
        return WrapComponent;
    };
    /**
     * Méthode permettant de merger proprement des objects
     * @param obj1
     * @param obj2
     * @returns {any}
     */
    HornetComponent.mergeObjects = function (obj1, obj2) {
        var merge = function (finalObj, obj) {
            if (typeof obj == "object") {
                var keys = Object.keys(obj);
                if (Array.isArray(keys) && keys.length > 0) {
                    keys.map(function (key) {
                        finalObj[key] = obj[key];
                    });
                }
            }
            return finalObj;
        };
        var finalObj = merge({}, obj1);
        return merge(finalObj, obj2);
    };
    /**
     * @param path éventuel chemin relatif à l'url de base du thème
     * @return l'url du thème CSS courant
     */
    HornetComponent.genUrlTheme = function (path) {
        return HornetComponent.genUrlThemeEmbedded(path);
    };
    /**
     * @param path éventuel chemin relatif à l'url de base du thème embarqué
     * @return l'url du thème CSS embarqué
     */
    HornetComponent.genUrlThemeEmbedded = function (path) {
        var themeUrl = "";
        var property = "themeName";
        if (hornet_js_utils_1.Utils.config.has(property)) {
            var themeName = hornet_js_utils_1.Utils.config.getOrDefault(property, "");
            if (themeName) {
                themeUrl = hornet_js_utils_1.Utils.buildStaticPath("/" + themeName + (path === undefined ? "" : path));
            }
        }
        return themeUrl;
    };
    /**
     * @param l'url de base du thème externe
     * @return l'url du thème CSS embarqué
     */
    HornetComponent.genUrlThemeExternal = function (path) {
        var themeUrl = "";
        var property = "themeHost";
        if (hornet_js_utils_1.Utils.config.has(property)) {
            themeUrl = hornet_js_utils_1.Utils.config.get(property);
            if (themeUrl) {
                themeUrl = themeUrl + (path === undefined ? "" : path);
            }
        }
        return themeUrl;
    };
    /**
     * Méthode permettant de générer une Url
     * @param path
     * @returns {string}
     */
    HornetComponent.prototype.genUrl = function (path) {
        return hornet_js_utils_1.Utils.buildContextPath(path);
    };
    /**
     * Permet de générer une Url de l'application depuis une url paramétrée
     * @param path
     * @param item
     * @returns {string}
     */
    HornetComponent.prototype.genUrlWithParams = function (path, item) {
        return hornet_js_utils_1.Utils.buildContextPath(pathToRegexp.compile(path)(item));
    };
    /**
     * Récupère le contexte Applicatif
     * @returns {string}
     */
    HornetComponent.prototype.getContextPath = function () {
        return hornet_js_utils_1.Utils.getContextPath();
    };
    /**
     * Permet de générer l'url vers les répertoires static de l'application
     * @param path
     * @returns {string}
     */
    HornetComponent.prototype.genUrlStatic = function (path) {
        return hornet_js_utils_1.Utils.buildStaticPath(path);
    };
    /**
     * Permet de récupérer tous les messages liés à l'internationalisation ainsi que la local
     * @returns {any} un objet contenant la locale et les messages internationalisés à utiliser.
     */
    HornetComponent.getInternationalization = function () {
        return hornet_js_utils_1.Utils.getCls("hornet.internationalization");
    };
    /**
     * Renvoie le ou les messages internationalisés correspondant à la clé indiquée, après avoir remplacé les valeurs paramétrables
     * avec celles indiquées.
     * @param keysString clé de message internationalisé
     * @param values valeurs de remplacement éventuelles
     * @param internationalization paramètre optionnel contenant les messages internationalisés et la locale
     * @returns {any} une chaîne de caractères ou un objet contenant des messages
     */
    HornetComponent.getI18n = function (keysString, values, internationalization) {
        if (internationalization === void 0) { internationalization = HornetComponent.getInternationalization(); }
        return i18n_utils_1.I18nUtils.getI18n(keysString, values, internationalization);
    };
    /**
     * Renvoie le ou les messages internationalisés correspondant à la clé indiquée, après avoir remplacé les valeurs paramétrables
     * avec celles indiquées.
     * @param keysString clé de message internationalisé
     * @param values valeurs de remplacement éventuelles
     * @returns {any} une chaîne de caractères ou un objet contenant des messages
     */
    HornetComponent.prototype.i18n = function (keysString, values) {
        return HornetComponent.getI18n(keysString, values);
    };
    /**
     * Retourne la valeur de la ressource si la property n'est pas initialisée
     * @param property : valeur à vérifié si elle est initialisée
     * @param ressource : valeur par défaut à retourner si la première n'est pas initialisée
     * @returns {any}
     */
    HornetComponent.prototype.initRessourceProperty = function (property, ressource) {
        var res = property;
        if (!res) {
            res = ressource;
        }
        return res;
    };
    /**
     * Méthode indiquant si le userAgent mentionne l'utilison en cours depuis un périphérique
     * mobile
     * Attention userAgent n'est pas ce qu'il y a de plus fiable.
     * @returns {boolean}
     */
    HornetComponent.prototype.isMobile = function () {
        var isMobile = false;
        if (!hornet_js_utils_1.Utils.isServer) {
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)
                || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0, 4))) {
                isMobile = true;
            }
        }
        return isMobile;
    };
    /** Indique si les erreurs sont encapsulées de façon à rediriger vers la page d'erreur*/
    HornetComponent.ERROR_MANAGED = true;
    return HornetComponent;
}(React.Component));
exports.HornetComponent = HornetComponent;

//# sourceMappingURL=hornet-component.js.map
