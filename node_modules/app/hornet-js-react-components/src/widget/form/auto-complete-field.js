"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * hornet-js-react-components - Ensemble des composants web React de base de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var React = require("react");
var abstract_field_1 = require("hornet-js-react-components/src/widget/form/abstract-field");
var auto_complete_selector_1 = require("hornet-js-react-components/src/widget/form/auto-complete-selector");
var _ = require("lodash");
var key_codes_1 = require("hornet-js-components/src/event/key-codes");
var auto_complete_state_1 = require("hornet-js-react-components/src/widget/form/auto-complete-state");
var datasource_master_1 = require("hornet-js-core/src/component/datasource/datasource-master");
var abstract_field_datasource_1 = require("hornet-js-react-components/src/widget/form/abstract-field-datasource");
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-react-components.widget.form.auto-complete-field");
var FilterTextType;
(function (FilterTextType) {
    FilterTextType[FilterTextType["beginWith"] = 1] = "beginWith";
    FilterTextType[FilterTextType["indexOf"] = 2] = "indexOf";
})(FilterTextType = exports.FilterTextType || (exports.FilterTextType = {}));
/**
 * Composant d'auto-complétion.
 * Les fonctions getCurrentValue et setCurrentValue s'appuient sur le champ caché contenant la valeur sélectionnée.
 */
var AutoCompleteField = /** @class */ (function (_super) {
    tslib_1.__extends(AutoCompleteField, _super);
    function AutoCompleteField(props, context) {
        var _this = _super.call(this, props, context) || this;
        var ariaSelectorId = props.name + "_select";
        //liste des choix possibles
        _this.state.choices = [];
        //item sélectionné
        _this.state.selectedIndex = null;
        //indique si la liste des choix est visible ou non
        _this.state.shouldShowChoices = false;
        //identifiant du selector
        _this.state.ariaSelectorId = ariaSelectorId;
        //loader
        _this.state.isApiLoading = false;
        if (_this.props.dataSource.results) {
            //liste de tous les choix (non filtré par le texte)
            _this.state.allChoices = _this.props.dataSource.results;
        }
        _this.autoCompleteState = new auto_complete_state_1.AutoCompleteState();
        return _this;
    }
    /**
     * Setter indiquant que l'API est en cours d'exécution
     * @param value valeur à utiliser
     * @param callback fonction de callback éventuelle
     * @returns {AutoComplete}
     */
    AutoCompleteField.prototype.setIsApiLoading = function (value, callback) {
        this.setState({ isApiLoading: value }, callback);
        return this;
    };
    /**
     * Setter des choix du composant
     * @param value tableau de choix
     * @param callback fonction de callback éventuelle
     * @returns {AutoComplete}
     */
    AutoCompleteField.prototype.setChoices = function (value, callback) {
        this.setState({ choices: value }, callback);
        return this;
    };
    /**
     * @inheritDoc
     */
    AutoCompleteField.prototype.componentDidMount = function () {
        if (!hornet_js_utils_1.Utils.isServer) {
            if (!_.isUndefined(this.props["var"])) {
                logger.warn("The var props is only available in DEV");
            }
        }
        this.mounted = true;
        logger.trace("auto-complete componentDidMount");
        this._throttledTriggerAction = _.throttle(this.triggerAction, this.state.delay);
        this.props.dataSource.on("fetch", this.fetchEventCallback);
        this.props.dataSource.on("add", this.addEventCallback);
        this.props.dataSource.on("delete", this.setResultCallback);
        this.props.dataSource.on("sort", this.setResultCallback);
        this.props.dataSource.on("filter", this.filterEventCallback);
        this.props.dataSource.on("init", this.initEventCallback);
        this.props.dataSource.on("loadingData", this.displaySpinner);
    };
    /**
     * @inheritDoc
     */
    AutoCompleteField.prototype.componentWillUnmount = function () {
        _super.prototype.componentWillUnmount.call(this);
        this.mounted = false;
        this.props.dataSource.removeListener("fetch", this.fetchEventCallback);
        this.props.dataSource.removeListener("add", this.addEventCallback);
        this.props.dataSource.removeListener("filter", this.filterEventCallback);
        this.props.dataSource.removeListener("init", this.initEventCallback);
        this.props.dataSource.removeListener("delete", this.setResultCallback);
        this.props.dataSource.removeListener("sort", this.setResultCallback);
        this.props.dataSource.removeListener("loadingData", this.displaySpinner);
    };
    /**
     * @inheritDoc
     */
    AutoCompleteField.prototype.componentWillUpdate = function (nextProps, nextState, nextContext) {
        _super.prototype.componentWillUpdate.call(this, nextProps, nextState, nextContext);
        if (this.state.delay != nextState.delay) {
            /* Le délai d'appel de l'action a changé : on doit donc refaire ici l'encaspulation avec _.throttle */
            this._throttledTriggerAction = _.throttle(this.triggerAction, nextState.delay);
        }
    };
    /**
     * @inheritDoc
     */
    AutoCompleteField.prototype.shouldComponentUpdate = function (nextProps, nextState, nextContext) {
        if (this.state.shouldShowChoices != nextState.shouldShowChoices
            || this.state.listDefaultValue !== nextState.listDefaultValue
            || ((nextState.choices && !this.state.choices)
                || (!nextState.choices && this.state.choices)
                || (nextState.choices && this.state.choices.length != nextState.choices.length))
            || !_.isEqual(nextState.choices, this.state.choices)
            || (this.state.errors != nextState.errors)
            || (this.state.readOnly != nextState.readOnly)
            || (this.state.disabled != nextState.disabled)) {
            return true;
        }
        return false;
    };
    /**
     * Génère le rendu spécifique du champ
     * @returns {any}
     */
    AutoCompleteField.prototype.renderWidget = function () {
        logger.trace("auto-complete  render");
        var shouldShow = this.shouldShowChoices();
        var hasError = this.hasErrors() ? " has-error" : "";
        var className = " autocomplete-content" + hasError;
        if (this.state.className) {
            className += " " + this.state.className;
        }
        var htmlProps = this.getHtmlProps();
        htmlProps = _.assign(htmlProps, {
            "onKeyDown": this.handleOnKeyDown,
            "onFocus": this.handleOnFocus,
            "onBlur": this.handleOnBlur,
            "onDoubleClick": this.handleOnFocus,
            "onClick": this.handleOnFocus,
            "onChange": this.handleChangeTextInput,
            "autoComplete": "off",
            "aria-autocomplete": "list",
            "aria-expanded": shouldShow,
            "aria-owns": this.state.ariaSelectorId,
            "aria-activedescendant": shouldShow ? this.state.ariaSelectorId + "_" + this.state.selectedIndex : undefined,
            "id": this.state.id ? this.state.id : this.getFreeTypingFieldName(),
            "type": "text",
            "name": this.getFreeTypingFieldName(),
            "className": className
        });
        /* Le champ caché contient l'identifiant de l'élément sélectionné. C'est cet identifiant qui est ensuite
         utilisé par les actions. */
        return (React.createElement("div", { className: "autocomplete-container" },
            React.createElement("input", { type: "hidden", name: this.getValueFieldName(), ref: this.registerHiddenInput }),
            React.createElement("input", tslib_1.__assign({}, htmlProps, { ref: this.registerTextInput, readOnly: !this.props.writable, "data-writable": this.props.writable })),
            React.createElement(auto_complete_selector_1.AutoCompleteSelector, { ref: "selector", choices: this.state.choices, onOptionSelected: this.onListWidgetSelected, selectorId: this.state.ariaSelectorId, maxHeight: this.props.maxHeight, showComponent: shouldShow, choicesSelected: this.state.listDefaultValue, autoCompleteState: this.autoCompleteState, disabled: this.state.disabled || this.state.readOnly, noResultLabel: this.state.noResultLabel })));
    };
    /**
     *
     * @param result
     */
    AutoCompleteField.prototype.fetchEventCallback = function (result) {
        this.choicesLoaderCallback(result);
        //dans le cas writable, le composant n'a pas besoin de recharger la liste des choix
        // elle est disponible directement
        if (this.props.writable) {
            if (!this.state.onListWidgetSelected) {
                this.prepareChoices(true);
            }
            else {
                this.prepareChoices(false);
            }
        }
        this.state.onListWidgetSelected = false;
    };
    /**
     * récupération des choix dans le datasource
     * @param result
     */
    AutoCompleteField.prototype.addEventCallback = function (result) {
        this.setResultCallback(result);
    };
    /**
     * récupération des choix dans le datasource
     * @param result
     */
    AutoCompleteField.prototype.setResultCallback = function (result) {
        this.state.allChoices = this.props.dataSource.results;
    };
    /**
     * récupération des choix possibles dans le datasource
     * @param filtered
     */
    AutoCompleteField.prototype.filterEventCallback = function (filtered) {
        this.state.allChoices = filtered;
        this.choicesLoaderCallback(filtered);
    };
    /**
     * récupération des choix à l'initialisation
     * @param result
     */
    AutoCompleteField.prototype.initEventCallback = function (result) {
        this.state.allChoices = result;
    };
    /**
     * retourne le texte saisi
     * @return {any} le texte actuellement saisi dans le champ de saisie libre
     */
    AutoCompleteField.prototype.getCurrentText = function () {
        var text = "";
        if (this.textInput) {
            text = this.textInput.value;
        }
        return text;
    };
    /**
     * Modifie la valeur du texte présent dans l'input
     * @param value texte à mettre dans l'input
     */
    AutoCompleteField.prototype.setCurrentText = function (value) {
        this.textInput.value = value;
    };
    /**
     * Réinitialise le champs autocomplete
     */
    AutoCompleteField.prototype.resetField = function () {
        this.resetSelectedValue();
        this.resetSelectedText();
        this.state.selectedIndex = -1;
        return this;
    };
    /**
     * Réinitialise la valeur de l'élément sélectionné contenu dans le champ caché
     */
    AutoCompleteField.prototype.resetSelectedValue = function () {
        if (this.hiddenInput) {
            this.hiddenInput.value = "";
        }
        this.autoCompleteState.choiceFocused = null;
        this.state.selectedIndex = -1;
    };
    /**
     * Réinitialise la valeur de l'élément sélectionné contenu dans le champ caché
     */
    AutoCompleteField.prototype.resetSelectedText = function () {
        if (this.textInput) {
            this.textInput.value = "";
        }
        if (this.refs.selector) {
            this.refs.selector.setCurrentTypedText("");
        }
    };
    /**
     * Fonction appelée lors d'un appui de touche sur le champ de saisie libre
     * @param e évènement
     * @protected
     */
    AutoCompleteField.prototype.handleOnKeyDown = function (e) {
        /* L'attribut DOM onKeyDown est éventuellement aussi renseigné sur le composant auto-complete */
        if (this.state.onKeyDown) {
            this.state.onKeyDown(event);
        }
        var key = e.keyCode;
        var shouldShow = this.state.shouldShowChoices === true;
        if (key == key_codes_1.KeyCodes.DOWN_ARROW) {
            if (e.altKey) {
                this.autoCompleteState.setFocusOn(this.state.selectedIndex, this.hiddenInput.value, null);
                this.showChoices();
            }
            else {
                this.navigateInChoices(1);
                this.isUpdated = true;
            }
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.UP_ARROW) {
            if (e.altKey) {
                this.hideChoices();
            }
            else {
                this.navigateInChoices(-1);
                this.isUpdated = true;
            }
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.ESCAPE) {
            //test si une valeur existait
            if (this.hiddenInput.value) {
                this.selectedChoice(this.hiddenInput.value);
                this.selectCurrentIndex();
            }
            // On demande le masquage des choix
            this.hideChoices();
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.ENTER) {
            //valide un choix si on est sur un autocomplete simple et writable
            //ne fait rien sinon (valide le formulaire)
            if (this.state.shouldShowChoices && this.state.writable) {
                e.preventDefault();
                this.validateSelectedValue(shouldShow);
            }
        }
        else if (key == key_codes_1.KeyCodes.SPACEBAR && !this.state.writable) {
            //valide un choix si on est sur un autocomplete et non writable
            if (this.state.shouldShowChoices) {
                e.preventDefault();
                this.validateSelectedValue(shouldShow);
            }
        }
        else if (key == key_codes_1.KeyCodes.TAB && !e.shiftKey && this.state.shouldShowChoices) {
            this.tabHandlerForValueChange(e, shouldShow);
        }
        else if (key == key_codes_1.KeyCodes.TAB && e.shiftKey) {
            this.tabHandlerForValueChange(e, shouldShow);
        }
        else if (key == key_codes_1.KeyCodes.HOME) {
            if (shouldShow) {
                this.state.selectedIndex = null;
                this.navigateInChoices(1);
            }
            else {
                this.state.selectedIndex = 0;
                this.selectCurrentIndex();
                this.hideChoices();
            }
            this.isUpdated = true;
            e.preventDefault();
        }
        else if (key == key_codes_1.KeyCodes.END) {
            if (shouldShow) {
                this.state.selectedIndex = null;
                this.navigateInChoices(-1);
            }
            else {
                this.state.selectedIndex = this.state.choices.length - 1;
                this.selectCurrentIndex();
                this.hideChoices();
            }
            this.isUpdated = true;
            e.preventDefault();
        }
    };
    /**
     * gère la tabulation
     * @param {__React.KeyboardEvent<HTMLElement>} e
     * @param {boolean} shouldShow
     * @param {boolean} preventDefault
     */
    AutoCompleteField.prototype.tabHandlerForValueChange = function (e, shouldShow) {
        if (this.isUpdated) {
            this.validateSelectedValue(shouldShow);
            this.isUpdated = false;
        }
        else {
            this.selectCurrentIndex();
            this.hideChoices();
        }
    };
    /**
     * valide le choix sélectionné
     * @param shouldShow indique si les résultats doivent être affichés
     */
    AutoCompleteField.prototype.validateSelectedValue = function (shouldShow) {
        var _this = this;
        if (shouldShow) {
            // place le selectedIndex sur le choix
            if (!this.state.selectedIndex) {
                this.state.choices.map(function (element, index) {
                    if (element.text == _this.getCurrentText()) {
                        _this.state.selectedIndex = index;
                    }
                });
            }
            //choix sélectionné
            var selection = (this.state.choices[this.state.selectedIndex] || this.state.allChoices[this.state.selectedIndex]);
            if (selection != null) {
                this.setCurrentValue(selection.value);
                this.props.dataSource.select(selection);
            }
            else {
                this.setCurrentValue(undefined);
                this.props.dataSource.select(undefined);
            }
            this.selectCurrentIndex();
            this.hideChoices();
        }
        else {
            this.showChoices();
        }
    };
    /**
     * Gestion de l'évènement onFocus pour le champ de saisie libre.
     * @param event
     */
    AutoCompleteField.prototype.handleOnFocus = function (event) {
        var _this = this;
        this.typedValueOnFocus = this.getCurrentText();
        this.state.focused = true;
        this.showChoices();
        /* L'attribut DOM onBlur est éventuellement aussi renseigné sur le composant auto-complete */
        if (this.state.onFocus) {
            this.state.onFocus(event);
        }
        if (this.state.allChoices) {
            if (this.isValidText(this.typedValueOnFocus) || !this.props.writable) {
                logger.trace("auto-complete : prise en compte du texte présent au focus : ", this.typedValueOnFocus);
                if (!this.props.dataSource.status) {
                    this.props.dataSource.init();
                }
                else {
                    if ((!this.props.writable) || this.state.choices.length == 0 && this.hiddenInput.value) {
                        this.setChoices(this.state.allChoices, function () {
                            if (_this.state.allChoices.length > 0) {
                                var index = _.findIndex(_this.state.allChoices, { text: _this.typedValueOnFocus });
                                _this.state.selectedIndex = index === undefined ? -1 : index;
                                _this.showChoices();
                                _this.changeSelectedChoiceWhenOneChoice(_this.typedValueOnFocus);
                            }
                        });
                    }
                }
                //this._throttledTriggerAction(this.typedValueOnFocus);
                this.changeSelectedChoiceWhenOneChoice(this.typedValueOnFocus);
            }
            else {
                this.setChoices(this.state.allChoices, function () {
                    if (_this.state.allChoices.length > 0) {
                        _this.showChoices();
                        _this.state.selectedIndex = -1;
                        _this.autoCompleteState.setFocusOn(_this.state.selectedIndex, "", null);
                    }
                });
            }
        }
        else {
            this.showChoices();
        }
        if (!this.hiddenInput || this.hiddenInput.value.length == 0 || !this.textInput || this.textInput.value.length == 0) {
            this.clearFilterData();
            this.state.selectedIndex = -1;
            this.autoCompleteState.setFocusOn(this.state.selectedIndex, "", null);
        }
        else {
            this.state.selectedIndex = _.findIndex(this.state.allChoices, { text: this.typedValueOnFocus });
            this.autoCompleteState.setFocusOn(this.state.selectedIndex, this.hiddenInput.value, null);
        }
    };
    /**
     * Fonction déclenchée lorsque le champ de saisie libre perd le focus
     * @param event
     */
    AutoCompleteField.prototype.handleOnBlur = function (event) {
        this.state.focused = false;
        /* L'attribut DOM onBlur est éventuellement aussi renseigné sur ce composant auto-complete */
        if (this.state.onBlur) {
            this.state.onBlur(event);
        }
        var currentText = this.getCurrentText();
        if (this.state.allChoices) {
            this.state.allChoices.filter(function (choice) {
                var res = false;
                if (!choice.text) {
                    res = choice.text.toLowerCase() === currentText.toLowerCase();
                }
                return res;
            });
        }
        if (!this.props.dataSource.selected || (this.props.dataSource.selected &&
            this.props.dataSource.selected.value &&
            this.props.dataSource.selected.value.toString() !== this.hiddenInput.value)) {
            if (!this.hiddenInput || !this.hiddenInput.value || this.hiddenInput.value.length == 0) {
                this.clearFilterData();
                if (!this.state.isShiftTab)
                    this.props.dataSource.select(undefined);
            }
            else {
                this.props.dataSource.select(_.find(this.state.allChoices, { value: this.hiddenInput.value }));
            }
        }
        this.hideChoices();
        this.isUpdated = false;
    };
    /**
     * indique aux élément esclave qu'un filter a été fait sur le maitre si le datasource en est un
     */
    AutoCompleteField.prototype.clearFilterData = function () {
        if (this.props.dataSource instanceof datasource_master_1.DataSourceMaster) {
            this.props.dataSource.getSlaves().forEach(function (item) {
                item.emit("filter", []);
            });
        }
    };
    /**
     * Fonction déclenchée sur une modification du champ de saisie libre
     * @param event
     */
    AutoCompleteField.prototype.handleChangeTextInput = function (event) {
        var _this = this;
        logger.trace("auto-complete handleChangeTextInput");
        /* Le texte a changé donc on réinitialise la valeur */
        this.resetSelectedValue();
        this.state.selectedIndex = null;
        /* L'attribut DOM onChange est éventuellement aussi renseigné sur le composant auto-complete */
        if (this.state.onChange) {
            this.state.onChange(event);
        }
        var newText = this.getCurrentText();
        this.clearFilterData();
        this.isUpdated = true;
        if (this.refs.selector) {
            this.refs.selector.setCurrentTypedText(newText);
        }
        if (this.isValidText(newText)) {
            logger.trace("auto-complete : prise en compte du texte saisi : ", newText);
            this._throttledTriggerAction(newText);
        }
        else {
            this.hideChoices();
        }
        if (newText.length == 0) {
            this.setChoices(this.state.allChoices, function () {
                if (_this.state.allChoices.length > 0) {
                    _this.showChoices();
                }
                else {
                    _this.props.dataSource.select(null);
                }
            });
        }
    };
    /**
     * si il n'y a plus qu'un choix écrit dans sa totalité,
     * valid ele choix
     * @param {string} newText
     */
    AutoCompleteField.prototype.changeSelectedChoiceWhenOneChoice = function (newText) {
        if (this.state.choices && this.state.choices[0] && this.state.choices.length === 1
            && _.deburr(newText).toLowerCase() == _.deburr(this.state.choices[0].text).toLowerCase()) {
            this.changeSelectedChoice(this.state.choices[0]);
            this.props.dataSource.select(this.state.choices[0]);
            this.autoCompleteState.setFocusOn(0, this.state.choices[0].value, 0);
        }
    };
    /**
     * change la valeur courrante
     * @param value
     * @returns {this}
     */
    AutoCompleteField.prototype.setCurrentValue = function (value) {
        _super.prototype.setCurrentValue.call(this, value);
        this.setState({ listDefaultValue: value });
        return this;
    };
    /**
     * Déclenche le chargement des éléments correspondant au texte saisi
     * @param newText texte saisi
     */
    AutoCompleteField.prototype.triggerAction = function (newText) {
        this.setIsApiLoading(true);
        this.props.dataSource.fetch(true, newText, true);
    };
    /**
     * Controle la longeur du text saisie avant de déclancher la recherche
     * @param cnt : boolean
     */
    AutoCompleteField.prototype.isMaxElementNumberReached = function (cnt) {
        return this.state.maxElements && cnt >= this.state.maxElements;
    };
    /**
     * Charge la liste de choix dans le composant
     */
    AutoCompleteField.prototype.prepareChoices = function (display) {
        var _this = this;
        if (display === void 0) { display = true; }
        var newChoices = [];
        var cnt = 0;
        if (this.state.choices) {
            this.state.choices.map(function (choice) {
                if (_this.findText(choice, _this.getCurrentText().toLowerCase()) && !_this.isMaxElementNumberReached(cnt)) {
                    newChoices.push(choice);
                    cnt++;
                }
            });
        }
        // mets a jour la liste des choix
        this.setChoices(newChoices, function () {
            if (newChoices.length > 0 && display) {
                //si il n'y a plus qu'un choix on le valide
                _this.changeSelectedChoiceWhenOneChoice(_this.getCurrentText());
                _this.showChoices();
            }
            else {
                _this.hiddenInput.value = "";
                _this.props.dataSource.select(null);
                _this.showChoices();
            }
        });
    };
    /**
     * Fonction déclenchée une fois les éléments de choix obtenus par la fonction choicesLoader
     * @param resultItems éléments obtenus. ceux-ci doivent contenir une propr
     */
    AutoCompleteField.prototype.choicesLoaderCallback = function (resultItems) {
        this.setIsApiLoading(false);
        this.setChoices(resultItems);
    };
    /**
     * test si le choix choice commence par current
     * @param choice
     * @param current
     * @returns {boolean}
     */
    AutoCompleteField.prototype.startsWithText = function (choice, current) {
        var choiceText = choice ? choice["text"] ? choice["text"].toLowerCase() : null : null;
        return _.startsWith(choiceText, current);
    };
    /**
     * teste si le texte current est contenu dans le choix choice
     * @param choice
     * @param current
     * @returns {boolean}
     */
    AutoCompleteField.prototype.indexOfText = function (choice, current) {
        var choiceText = choice ? choice["text"] ? choice["text"].toLowerCase() : null : null;
        if (choiceText && (choiceText.indexOf(current) >= 0)) {
            return true;
        }
        return false;
    };
    /**
     * indique si le texte current se trouve dans le choix
     * @param choice
     * @param current
     * @returns {boolean}
     */
    AutoCompleteField.prototype.findText = function (choice, current) {
        if (typeof this.props.filterText == "function") {
            return this.props.filterText(choice, current);
        }
        else if (this.props.filterText == FilterTextType.beginWith) {
            return this.startsWithText(choice, current);
        }
        else if (this.props.filterText == FilterTextType.indexOf) {
            return this.indexOfText(choice, current);
        }
        return false;
    };
    /**
     * Fonction appelée lorsque l'utilisateur a choisi un élément de la liste de choix.
     * @param choice élément sélectionné
     */
    AutoCompleteField.prototype.changeSelectedChoice = function (choice) {
        if (this.refs.selector) {
            this.refs.selector.setCurrentTypedText("");
        }
        this.textInput.value = choice ? choice.text : "";
        this.hiddenInput.value = choice ? choice.value : "";
    };
    /**
     * Recupere l'index de l'element selectionné
     * @param choice
     */
    AutoCompleteField.prototype.selectedChoice = function (choice) {
        var indexSelected = null;
        if (this.state.choices) {
            this.state.choices.map(function (item, index) {
                if (item.value == choice) {
                    indexSelected = index;
                }
            });
            this.setCurrentValue(choice);
        }
    };
    /**
     * Fonction appelée lorsque l'utilisateur clique sur un item de la liste des valeurs possibles
     * @param event
     */
    AutoCompleteField.prototype.onListWidgetSelected = function (event, choice) {
        if (choice) {
            logger.trace("Selection click [", choice.value, "]:", choice.text);
            var index = _.findIndex(this.state.choices, choice);
            this.state.selectedIndex = index;
            this.autoCompleteState.choiceFocused = index;
            this.changeSelectedChoice(choice);
            this.hiddenInput.value = choice.value;
            this.selectedChoice(choice.value);
            this.props.dataSource.select(choice);
        }
        this.state.onListWidgetSelected = true;
        this.hideChoices();
    };
    /**
     * Retourne true si le texte indiqué correspond aux critères de taille minimale
     * @param text
     * @returns {boolean}
     * @protected
     */
    AutoCompleteField.prototype.isValidText = function (text) {
        return (text != null && text.length >= this.state.minValueLength);
    };
    /**
     * Navigue au sein de la liste de choix
     * @param delta {number} indique de combien d'éléments on doit se déplacer par rapport à l'élément actuellement sélectionné
     * @protected
     */
    AutoCompleteField.prototype.navigateInChoices = function (delta) {
        var _this = this;
        var newIndex = this.state.selectedIndex === null ? (delta === 1 ? 0 : delta) : this.state.selectedIndex + delta;
        var choicesLength = this.state.choices ? this.state.choices.length : 0;
        if (newIndex < 0) {
            //On va à la fin
            newIndex = choicesLength - 1;
        }
        else if (newIndex >= choicesLength) {
            //On retourne au début
            newIndex = 0;
        }
        // on valide le choix sur lequel on est
        this.setState({ selectedIndex: newIndex }, function () {
            _this.selectCurrentIndex();
            if (!_this.state.shouldShowChoices) {
                var selection = (_this.state.choices[_this.state.selectedIndex]);
                if (selection != null) {
                    _this.changeSelectedChoice(selection);
                    _this.setCurrentValue(selection.value);
                }
            }
            _this.autoCompleteState.setFocusOn(_this.state.selectedIndex, _this.hiddenInput.value, newIndex);
        });
        // On s'assure de l'affichage de la liste déroulante
        if (this.state.shouldShowChoices) {
            this.showChoices();
        }
    };
    /**
     * Selectionne l'élement actuellement en surbrillance dans la liste de choix
     * @return boolean si une sélection a effectivement eu lieu
     * @protected
     */
    AutoCompleteField.prototype.selectCurrentIndex = function () {
        var selection = (this.state.choices || [])[this.state.selectedIndex];
        if (selection != null) {
            this.changeSelectedChoice(selection);
            return true;
        }
        return false;
    };
    /**
     * Demande l'affichage du composant de choix
     * @public
     */
    AutoCompleteField.prototype.showChoices = function () {
        if (this.state.shouldShowChoices !== true && this.state.focused) {
            if (this.isValidText(this.textInput.value) || this.textInput.value.length == 0 || !this.props.writable) {
                this.setState({ shouldShowChoices: true });
            }
        }
    };
    /**
     * Demande le masquage du composant de choix
     * @public
     */
    AutoCompleteField.prototype.hideChoices = function () {
        if (this.state.shouldShowChoices !== false) {
            this.setState({ shouldShowChoices: false });
        }
    };
    /**
     * @return {boolean} true si le composant de liste doit s'afficher
     * @protected
     */
    AutoCompleteField.prototype.shouldShowChoices = function () {
        return this.state.shouldShowChoices === true;
    };
    /**
     * @return {string} le nom du champ caché contenant la valeur
     */
    AutoCompleteField.prototype.getValueFieldName = function () {
        return this.state.name + "." + this.state.valueKey;
    };
    /**
     * @return {string} le nom du champ de saisie libre
     */
    AutoCompleteField.prototype.getFreeTypingFieldName = function () {
        return this.state.name + "." + this.state.labelKey;
    };
    /**
     * Surcharge le rendu des erreurs de validation : le nom du champ à mettre en évidence est le champ de saisie libre
     * @override
     */
    AutoCompleteField.prototype.renderErrors = function () {
        var fieldErrorProps = {
            errors: this.state.errors,
            fieldName: this.getFreeTypingFieldName()
        };
        var basicFieldErrorProps = {
            errors: this.state.errors,
            fieldName: this.state.name
        };
        var Error = this.state.errorComponent;
        return (React.createElement("div", null,
            React.createElement(Error, tslib_1.__assign({}, fieldErrorProps)),
            React.createElement(Error, tslib_1.__assign({}, basicFieldErrorProps))));
    };
    /**
     * On enregistre également le champ contenant la valeur dans la classe parente DomAdapter, ce qui fait les liens
     entre le formulaire, le champ HTML et le composant React.
     * @param hiddenInput
     */
    AutoCompleteField.prototype.registerHiddenInput = function (hiddenInput) {
        this.hiddenInput = hiddenInput;
        this.registerHtmlElement(hiddenInput);
    };
    /**
     *  Conserve la valeur du champs saisie
     * @param textInput
     */
    AutoCompleteField.prototype.registerTextInput = function (textInput) {
        this.textInput = textInput;
    };
    /** on mets le focus sur l'input */
    AutoCompleteField.prototype.setFocus = function () {
        this.state.focused = true;
        this.textInput.focus();
        return this;
    };
    /**
     * teste si le composant a des erreurs
     * @override
     */
    AutoCompleteField.prototype.hasErrors = function () {
        var fieldErrors = null;
        if (this.state.errors) {
            fieldErrors = this.state.errors.filter(function (error) {
                var name = this.state.name + "." + this.state.labelKey;
                return (error.field == name || error.field == this.state.name);
            }, this);
        }
        if (fieldErrors && (fieldErrors.length > 0)) {
            return true;
        }
        return false;
    };
    AutoCompleteField.defaultProps = _.assign({
        minValueLength: 1,
        readOnly: false,
        disabled: false,
        delay: 1000,
        valueKey: "value",
        labelKey: "text",
        maxHeight: null,
        writable: true,
        filterText: FilterTextType.indexOf
    }, abstract_field_1.AbstractField.defaultProps);
    return AutoCompleteField;
}(abstract_field_datasource_1.AbstractFieldDatasource));
exports.AutoCompleteField = AutoCompleteField;

//# sourceMappingURL=auto-complete-field.js.map
