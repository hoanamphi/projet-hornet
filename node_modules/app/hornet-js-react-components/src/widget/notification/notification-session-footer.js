"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var hornet_js_utils_1 = require("hornet-js-utils");
var hornet_component_1 = require("hornet-js-react-components/src/widget/component/hornet-component");
var hornet_superagent_1 = require("hornet-js-core/src/services/hornet-superagent");
var wakeup_node_1 = require("hornet-js-core/src/services/default/wakeup-node");
var picto_1 = require("hornet-js-react-components/src/img/picto");
var classNames = require("classnames");
var moment = require("moment-timezone");
moment.duration.fn.format = function () {
    var str = "";
    if (this.days() > 1)
        str = str + Math.floor(this.days()) + "d ";
    if (this.hours() > 1)
        str = str + Math.floor(this.hours()) + "h ";
    if (this.minutes() > 1)
        str = str + Math.floor(this.minutes()) + "m ";
    if (this.seconds() > 1)
        str = str + Math.floor(this.seconds()) + "s ";
    return str;
};
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-react-components.widget.notification.notification-session-footer");
var NotificationSessionFooter = /** @class */ (function (_super) {
    tslib_1.__extends(NotificationSessionFooter, _super);
    function NotificationSessionFooter(props, context) {
        var _this = _super.call(this, props, context) || this;
        /**
         * Service middleware pour le layout
         */
        _this.wakeUpNodeService = new wakeup_node_1.WakeUpNode();
        _this.state.offset = 0;
        return _this;
    }
    NotificationSessionFooter.prototype.componentDidMount = function () {
        window.addEventListener("scroll", this.handleScroll);
        this.listen(hornet_superagent_1.SESSION_REFRESHED_NOTIFICATION_EVENT, this.handleRefresh);
        this.listen(hornet_superagent_1.SESSION_WILL_EXPIRE_START_NOTIFICATION_EVENT, this.handleWillExpireStart);
        this.listen(hornet_superagent_1.SESSION_WILL_EXPIRE_NOTIFICATION_EVENT, this.handleWillExpire);
    };
    NotificationSessionFooter.prototype.componentWillUnmount = function () {
        window.removeEventListener("scroll", this.handleScroll);
        this.remove(hornet_superagent_1.SESSION_REFRESHED_NOTIFICATION_EVENT, this.handleRefresh);
        this.remove(hornet_superagent_1.SESSION_WILL_EXPIRE_START_NOTIFICATION_EVENT, this.handleWillExpireStart);
        this.remove(hornet_superagent_1.SESSION_WILL_EXPIRE_NOTIFICATION_EVENT, this.handleWillExpire);
    };
    NotificationSessionFooter.prototype.render = function () {
        return (this.state.isVisible ? this.renderNotification() : React.createElement("div", null));
    };
    /**
     * Méthode permettant de faire le rendu du bloc de notification
     * @returns {JSX.Element}
     */
    NotificationSessionFooter.prototype.renderNotification = function () {
        var style = {};
        /*si le footer est visible, le composant s'affichera au dessus de celui-ci*/
        if (this.state.offset < 0) {
            style = { bottom: 0 };
        }
        var divProps = {
            className: "notification-timeout flex-container",
            style: style,
            name: this.state.name,
            title: this.state.title,
            id: "notification-session"
        };
        var labelClasses = {
            "fl": true,
            "notification-session-message": true,
            "notification-expanded": !this.state.reduced,
            "notification-reduced": this.state.reduced
        };
        var imgSrc = picto_1.Picto.darkBlue.next;
        if (this.state.reduced) {
            imgSrc = picto_1.Picto.darkBlue.previous;
        }
        var tabIndex = this.state.reduced ? -1 : 0;
        return (React.createElement("div", tslib_1.__assign({}, divProps),
            React.createElement("div", { className: classNames(labelClasses) },
                React.createElement("div", null, this.formateMessage()),
                React.createElement("div", null,
                    React.createElement("a", { onClick: this.handlClickWakeUp, tabIndex: tabIndex }, this.i18n(this.props.messages).reconnexion))),
            React.createElement("div", { className: "fl", onClick: this.handleToggleNotification },
                React.createElement("a", { href: "", onClick: this.handleToggleNotification, tabIndex: 0 },
                    React.createElement("img", { src: imgSrc, style: { height: "3em" }, onClick: this.handleToggleNotification })))));
    };
    NotificationSessionFooter.prototype.handlClickWakeUp = function () {
        var _this = this;
        if (this.props.handlClickWakeUp) {
            this.props.handlClickWakeUp();
        }
        else {
            this.wakeUpNodeService.wakeUp().then(function () {
                _this.handleRefresh();
            });
        }
    };
    /**
     * Méthode permettant de formater le message à afficher dans le bloc de notification
     * @returns {string}
     */
    NotificationSessionFooter.prototype.formateMessage = function () {
        var message = this.i18n(this.props.messages).countDownExpiredMesage;
        var duration = this.formateTime();
        if (duration > 1) {
            var time = moment.duration(duration, "milliseconds").format("H:mm:ss");
            message = this.i18n(this.props.messages).countDownNormalMessage + time;
        }
        return message;
    };
    /**
     * Méthode permettant de formater le state expireIn au format Date
     * @returns {number}
     */
    NotificationSessionFooter.prototype.formateTime = function () {
        return new Date(this.state.expireIn).getTime();
    };
    /**
     * Méthode permettant de réduire la notification
     */
    NotificationSessionFooter.prototype.handleToggleNotification = function () {
        this.setState({ reduced: !this.state.reduced });
    };
    /**
     * Méthode permettant de rafraichir la notification
     * @param {HornetEvent<SessionEvent>} ev
     */
    NotificationSessionFooter.prototype.handleRefresh = function (ev) {
        var elementsToUpdate = {
            isVisible: false,
            reduced: false
        };
        if (ev && ev.detail && ev.detail.value) {
            elementsToUpdate["expireIn"] = ev.detail.value;
        }
        this.setState(elementsToUpdate);
    };
    /**
     * Méthode permettant de rafraichir la notification
     * @param {HornetEvent<SessionEvent>} ev
     */
    NotificationSessionFooter.prototype.handleWillExpireStart = function (ev) {
        this.setState({ isVisible: true, expireIn: ev.detail.value });
    };
    /**
     * Méthode permettant d'avertir d'une fin de session
     * @param {HornetEvent<SessionEvent>} ev
     */
    NotificationSessionFooter.prototype.handleWillExpire = function (ev) {
        var _this = this;
        // console.log(ev.detail.value);
        this.setState({ expireIn: ev.detail.value }, function () {
            setTimeout(_this.handleToggleNotification, _this.props.displayDuration);
        });
    };
    /**
     * Métohde de gestion du scroll à l'écran
     */
    NotificationSessionFooter.prototype.handleScroll = function () {
        var footer = document.getElementById(this.state.footer);
        var rect = footer.getBoundingClientRect();
        var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
        //sauvegarde la taille visible du footer
        var height = -(rect.top - viewHeight);
        this.setState({ size: height });
        /*si le footer est visible, le composant s'affichera au dessus de celui-ci*/
        var visible = false;
        if (footer) {
            visible = this.checkvisible(footer);
        }
        this.setState({
            offset: height,
            visible: visible
        });
    };
    /**
     * Calcule si un élément est présent ou non a l'écran
     * @param {Element} elm - l'élément a rechercher
     * @return {boolean} true si l'élément est présent
     */
    NotificationSessionFooter.prototype.checkvisible = function (elm) {
        var rect = elm.getBoundingClientRect();
        var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
        //sauvegarde la la taille visible de l'élément
        var height = -(rect.top - viewHeight) + 40;
        this.setState({ size: height });
        return !(rect.bottom < 0 || rect.top - viewHeight >= 0);
    };
    NotificationSessionFooter.defaultProps = ({
        offset: 0,
        header: "header-container",
        footer: "footer-container",
        messages: "notificationSession",
        displayDuration: 5000
    });
    return NotificationSessionFooter;
}(hornet_component_1.HornetComponent));
exports.NotificationSessionFooter = NotificationSessionFooter;

//# sourceMappingURL=notification-session-footer.js.map
