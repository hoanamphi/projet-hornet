"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * hornet-js-core - Ensemble des composants qui forment le coeur de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var _ = require("lodash");
var promise_api_1 = require("hornet-js-utils/src/promise-api");
var datasource_1 = require("hornet-js-core/src/component/datasource/datasource");
var technical_error_1 = require("hornet-js-utils/src/exception/technical-error");
var codes_error_1 = require("hornet-js-utils/src/exception/codes-error");
var hornet_js_utils_1 = require("hornet-js-utils");
var array_utils_1 = require("hornet-js-utils/src/array-utils");
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-core.component.datasource.paginate-datasource");
exports.ITEMS_PER_PAGE_ALL = 2147483647;
/**
 * @enum enumeration pour la navigation dans le paginateur
 */
var Direction;
(function (Direction) {
    Direction[Direction["PREVIOUS"] = -1] = "PREVIOUS";
    Direction[Direction["NEXT"] = -2] = "NEXT";
    Direction[Direction["FIRST"] = -3] = "FIRST";
    Direction[Direction["LAST"] = -4] = "LAST";
})(Direction = exports.Direction || (exports.Direction = {}));
/***
 * @classdesc Classe de representation d'une pagination
 * @class
  */
var Paginator = /** @class */ (function () {
    /**
     * @constructs
     * @param {Pagination} pagination configuration de la pagination
     */
    function Paginator(pagination) {
        this._pagination = pagination;
        this.items = [];
    }
    Object.defineProperty(Paginator.prototype, "pagination", {
        get: function () {
            return this._pagination;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Paginator.prototype, "sort", {
        get: function () {
            return this._sort;
        },
        set: function (sort) {
            this._sort = sort;
        },
        enumerable: true,
        configurable: true
    });
    Paginator.prototype.calculateNbPages = function (itemsTot) {
        var nbTot = itemsTot || this._pagination.totalItems;
        return _.round(nbTot / this._pagination.itemsPerPage) + ((nbTot % this._pagination.itemsPerPage) > 0 ? 1 : 0);
    };
    /**
     * Methode de gestion de la pagination
     * @param {(number|Direction)} page numero de la page ou la direction, première page à index 1.
     */
    Paginator.prototype.paginate = function (page) {
        if (page > 0) {
            this._pagination.pageIndex = page;
        }
        else if (page >= Direction.LAST && page < 0) {
            switch (page) {
                case Direction.FIRST:
                    this._pagination.pageIndex = 1;
                    break;
                case Direction.LAST:
                    this._pagination.pageIndex = this.items.length;
                    break;
                case Direction.PREVIOUS:
                    this._pagination.pageIndex = this._pagination.pageIndex - 1;
                    break;
                case Direction.NEXT:
                    this._pagination.pageIndex = this._pagination.pageIndex + 1;
                    break;
            }
        }
        else if (page < Direction.LAST) {
            //TODO throw
        }
        return this.extractPage(null, false);
    };
    /**
     * Extraction des données de la page de pagination
     * @param {Array<T>} itemsTot liste pouvant servir pour l'extraction
     * @param {boolean} forceUpdate force la mise a jour et va lire de itemsTot sinon prend dans la variable d'instance
     */
    Paginator.prototype.extractPage = function (itemsTot, forceUpdate) {
        if (forceUpdate === void 0) { forceUpdate = false; }
        var page = [];
        if (!forceUpdate && this.items.length >= this._pagination.pageIndex) {
            page = this.items[this._pagination.pageIndex];
        }
        else if (itemsTot && this._pagination.itemsPerPage) {
            page = itemsTot;
            if (this._pagination.pageIndex) {
                page = page.slice((this._pagination.pageIndex - 1) * this._pagination.itemsPerPage);
                page = page.slice(0, this._pagination.itemsPerPage);
            }
            this.items[this._pagination.pageIndex] = page;
        }
        return page;
    };
    /**FIRST
     * Change le nombre d'items par page
     * @param {number} itemsPerPage nombre d'items par page
     */
    Paginator.prototype.setItemsPerPage = function (itemsPerPage) {
        this._pagination.itemsPerPage = itemsPerPage;
        this._pagination.pageIndex = 1;
        this.items = [];
    };
    Paginator.prototype.reset = function () {
        this._pagination.pageIndex = 1;
        this.items = [];
        this._pagination.totalItems = 0;
        this._pagination.nbPages = 0;
    };
    /**
     * initialise les differentes pages suivant l'objet de pagination
     * @param {Array<T>} itemsTot liste des items à decouper en page
     * @param {number} totalItems nombre total d'items (pagination serveur)
     */
    Paginator.prototype.preparePagination = function (itemsTot, totalItems) {
        this.paginate(Direction.FIRST);
        while (this.extractPage(itemsTot, true).length == this._pagination.itemsPerPage) {
            this.paginate(Direction.NEXT);
        }
        this.paginate(Direction.FIRST);
        this._pagination.totalItems = totalItems || itemsTot.length;
        //this._pagination.nbPages = this.items.length / this._pagination.itemsPerPage;
        this._pagination.nbPages = this.calculateNbPages();
    };
    /**
     * initialise les differentes pages suivant l'objet de pagination
     * @param {Array<T>} itemsTot liste des items à decouper en page
     * @param {number} totalItems nombre total d'items (pagination serveur)
     */
    Paginator.prototype.setCurrentPage = function (items, totalItems) {
        this.extractPage(items, true);
        this._pagination.totalItems = totalItems || items.length;
        this._pagination.nbPages = this.calculateNbPages();
    };
    return Paginator;
}());
exports.Paginator = Paginator;
/***
 * @classdesc Classe de base des datasources
 * elle contient une methode pour récupérer des datas, varie selon le type de datasource;
 * elle implémente une methode qui transforme les données récupérées selon une classe de mapping  {@link DataSourceMap} afin de l'exploiter directement par l'IHM.
 * @class
 * @extends EventEmitter
 */
var PaginateDataSource = /** @class */ (function (_super) {
    tslib_1.__extends(PaginateDataSource, _super);
    /***
     * @param {(DataSourceConfig|DataSourceConfigPage|Array<T>)} config accepte soit une liste de l'éléments Array<T>, soit un service DataSourceConfig | DataSourceConfigPage
     * @param {Pagination} pagination pagination à appliquer.
     * @param {DataSourceMap} keysMap  utilisée pour la transformation des resultats du fetch.
     * @param {Object} options liste de paramètres supplémentaires à transmettre au fetch
     */
    function PaginateDataSource(config, pagination, keysMap, options) {
        var _this = _super.call(this, config, keysMap, options) || this;
        _this.config = config;
        _this.keysMap = keysMap;
        _this.options = options;
        _this._paginator = new Paginator(pagination);
        _this.initPaginateDataSource();
        _this.initSort();
        _.map(["sort", "pagination", "select", "add", "filter", "delete"], function (event) {
            _this.on(event, _this.saveSelected);
        });
        return _this;
    }
    PaginateDataSource.prototype.initPaginateDataSource = function () {
        if (this.isDataSourceArray) {
            (this.initAsync && this.initAsync.isAsync) ? this.initData() : this.initDataSync() && this.updatePaginator(this.datasourceResults);
        }
    };
    /***
     * Méthode qui déclenche un fetch appelé pour initialiser un datasource.
     * @param {any} args  paramètres à renseigner pour l'appel de la méthode de récupération des données.
     * Déchenche un event init
     */
    PaginateDataSource.prototype.init = function (args) {
        //pour le paginate-datasource on fera plutot un initPaginateDataSource
    };
    Object.defineProperty(PaginateDataSource.prototype, "pagination", {
        get: function () {
            return this._paginator.pagination;
        },
        set: function (pagination) {
            this._paginator = new Paginator(pagination);
        },
        enumerable: true,
        configurable: true
    });
    PaginateDataSource.prototype.updatePaginator = function (items, totalItems) {
        if (this.isDataSourceArray) {
            this._paginator.preparePagination(items, totalItems);
        }
        else {
            this._paginator.setCurrentPage(items, totalItems);
        }
    };
    /***
     * Réinitialise la pagination et envoie un event de pagination
     */
    PaginateDataSource.prototype.initPaginator = function () {
        this.emit("pagination", {
            list: this.results, pagination: {
                pageIndex: 0,
                itemsPerPage: this._paginator.pagination.itemsPerPage,
                totalItems: 0
            }
        });
    };
    /***
     * Réinitialise le sort
     */
    PaginateDataSource.prototype.initSort = function () {
        this._paginator.sort = this.defaultSort ? this.defaultSort.sort : null;
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.deleteAll = function () {
        _super.prototype.deleteAll.call(this);
        this.initSort();
        this.initPaginator();
    };
    /***
     * @inheritdoc
     * @param {boolean} reloadPage indicateur pour recharger la page en cours, sinon ce sera la première page.
     */
    PaginateDataSource.prototype.reload = function (reloadPage, forceUpdate) {
        if (reloadPage === void 0) { reloadPage = false; }
        if (forceUpdate === void 0) { forceUpdate = false; }
        this.initSort();
        this.updatePaginator(this.results, this._paginator.pagination.totalItems);
        reloadPage ? this.reloadPage(forceUpdate) : this.goToPage(Direction.FIRST);
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.fetch = function (triggerFetch, args, noSave) {
        if (!noSave) {
            this.fetchArgsSaved = args;
            args = this.getFetchArgs("pagination", this.pagination);
        }
        return _super.prototype.fetch.call(this, triggerFetch, args, true);
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.fetchData = function (triggerFetch, args) {
        var _this = this;
        return _super.prototype.fetchData.call(this, triggerFetch, this._paginator.sort ? _.extend(this.getFetchArgs("sort", this._paginator.sort), args) : args)
            .then(function (results) {
            _this.pagination.pageIndex = _this.pagination.pageIndex || 1;
            _this.updatePaginator(_this.datasourceResults, _this._paginator.pagination.totalItems);
            //this.emit('pagination', {list: results, pagination: this._paginator.pagination});
            return results;
        });
    };
    /***
     * méthode qui appelle (juste après un fetch) la fonction de {@link Datasource#transformData} et déclenche un evènement "fetch" lorsque les données sont disponibles
     * @param result les données brutes.
     * @return renvoie les données transformées à partir des données brutes et la classe de mapping  {@link DataSourceMap}
     */
    PaginateDataSource.prototype.transformData = function (result) {
        var data = result[0];
        if (data && data["errors"]) {
            var error = new technical_error_1.TechnicalError("ERR_TECH_" + codes_error_1.CodesError.DATASOURCE_RESPONSE_ERROR, data["errors"]);
            this.emit("error", error);
            return promise_api_1.Promise.reject(error);
        }
        if (!this.isDataSourceArray) {
            if (!data) {
                this._paginator.pagination.totalItems = 0;
                this._paginator.pagination.pageIndex = 1;
                return _super.prototype.transformData.call(this, []);
            }
            else {
                this._paginator.pagination.totalItems = data["nbTotal"];
                this._paginator.pagination.pageIndex = data["pagination"].pageIndex;
                return _super.prototype.transformData.call(this, data["liste"]);
            }
        }
        else {
            return _super.prototype.transformData.call(this, data instanceof Array ? data : [data]);
        }
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.sort = function (options) {
        var _this = this;
        this.emit("loadingData", true);
        this._paginator.sort = options.sortDatas;
        promise_api_1.Promise.resolve().then(function () {
            try {
                if (_this.isDataSourceArray) {
                    options.compare = options.compare || _this.defaultSort;
                    _super.prototype.sortData.call(_this, options);
                    var currentPageIdx = _this.pagination.pageIndex;
                    _this.updatePaginator(_this.datasourceResults);
                    var currentPage = _this._paginator.paginate(currentPageIdx);
                    _this.emit("sort", currentPage, options.sortDatas);
                    return currentPage;
                }
                else {
                    return _this.fetchData(false, _this.getFetchArgs("pagination", _this.pagination))
                        .then(function (results) {
                        _this.emit("sort", results, options.sortDatas);
                        return results;
                    });
                }
            }
            catch (e) {
                var error = new technical_error_1.TechnicalError("ERR_TECH_" + codes_error_1.CodesError.DATASOURCE_SORT_ERROR, null, e);
                _this.emit("error", error);
            }
        }).finally(function () {
            _this.emitEvent("loadingData", false);
        });
    };
    /***
     * Renvoie un sous-ensemble des resultats filtrés
     * @param config correspond soit aux critères de filtrage soit à une fonction (appelée à chaque itération) {@link https://lodash.com/docs/#filter}
     * @param cancelFilterHistory false si on souhaite garder un historique des filtres true sinon. false par défaut
     * @example
     * dataSource.on("filter", (filteredResult)=>{
     *       //staff
     *   })
     * dataSource.filter(config, cancelFilterHistory);
     * @void
     */
    PaginateDataSource.prototype.filter = function (config, cancelFilterHistory) {
        var _this = this;
        if (cancelFilterHistory === void 0) { cancelFilterHistory = false; }
        this.emit("loadingData", true);
        if (this.isDataSourceArray) {
            if (cancelFilterHistory) {
                if (!this._filtering_flag) {
                    //backup
                    this._results_backup = this.datasourceResults;
                    this._filtering_flag = true;
                }
                else {
                    //restore
                    this.datasourceResults = this._results_backup;
                }
            }
        }
        promise_api_1.Promise.resolve().then(function () {
            try {
                if (_this.isDataSourceArray) {
                    _this.datasourceResults = _.filter(_this.results, config);
                    _this.updatePaginator(_this.datasourceResults);
                    _this.goToPage(Direction.FIRST);
                }
                else {
                    _this.fetchData(false, _this.getFetchArgs("filter", config)).then(function () {
                        _this.emitEvent("filter", _this.results);
                    });
                }
            }
            catch (e) {
                var error = new technical_error_1.TechnicalError("ERR_TECH_" + codes_error_1.CodesError.DATASOURCE_FILTER_ERROR, null, e);
                _this.emit("error", error);
            }
        }).finally(function () {
            _this.emitEvent("loadingData", false);
        });
    };
    /***
     * Ajout un élément ou des éléments au result du datasource
     * cette action déclenche l'évènement add.
     * @param {Boolean} triggerFetch param inutilisé, cette fonction déclenchera un évènement "pagination" .
     * @param {(T|T[])[]} items correspond aux données à ajouter, un appel à la méthode {@link DataSource#transformData} sera effectué
     * @example
     * dataSource.on("add", (IncreasedResult)=>{
     *       //staff
     *   })
     * dataSource.add();
     * @void
     */
    PaginateDataSource.prototype.add = function (triggerFetch) {
        var _this = this;
        if (triggerFetch === void 0) { triggerFetch = false; }
        var items = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            items[_i - 1] = arguments[_i];
        }
        this.addData.apply(this, [false].concat(items)).catch(function (e) {
            var error = new technical_error_1.TechnicalError("ERR_TECH_" + codes_error_1.CodesError.DATASOURCE_DELETE_ERROR, null, e);
            _this.emit("error", error);
        });
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.addData = function (triggerFetch) {
        var _this = this;
        if (triggerFetch === void 0) { triggerFetch = false; }
        var items = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            items[_i - 1] = arguments[_i];
        }
        return _super.prototype.addData.apply(this, [false].concat(items)).then(function (result) {
            if (result && result.length != 0) {
                _this.updatePaginator(_this.datasourceResults);
                _this.goToPage(Direction.FIRST);
            }
            return result;
        });
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.deleteData = function (triggerFetch) {
        var _this = this;
        if (triggerFetch === void 0) { triggerFetch = false; }
        var items = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            items[_i - 1] = arguments[_i];
        }
        return _super.prototype.deleteData.apply(this, [triggerFetch].concat(items)).then(function (result) {
            _this.updatePaginator(_this.datasourceResults);
            _this.goToPage(Direction.FIRST);
            return result;
        });
    };
    /***
     * enlève un élément ou des éléments au result du datasource
     * cette action déclenche l'évènement delete
     * @param {Boolean} triggerFetch param inutilisé, cette fonction déclenchera un évènement "pagination" .
     * @param {(T|T[])[]} items correspond aux données à ajouter, un appel à la méthode {@link DataSource#transformData} sera effectué
     * @void
     */
    PaginateDataSource.prototype.delete = function (triggerFetch) {
        var _this = this;
        var items = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            items[_i - 1] = arguments[_i];
        }
        this.deleteData.apply(this, [triggerFetch].concat(items)).then(function (results) {
            _this.emit("delete", results);
        });
    };
    /**
     * navigue vers une page
     * @param {(number|Direction)} page la page a extraire
     */
    PaginateDataSource.prototype.goToPage = function (page) {
        var _this = this;
        if (this.isDataSourceArray) {
            this.emit("loadingData", true);
            this.emit("pagination", { list: this._paginator.paginate(page), pagination: this._paginator.pagination });
            this.emit("loadingData", false);
        }
        else {
            this._paginator.paginate(page);
            this.fetchData(false, this.getFetchArgs("pagination", this.pagination)).then(function (results) {
                _this.emit("pagination", { list: results, pagination: _this._paginator.pagination });
            });
        }
    };
    /**
     * retourne les items d'une page en particulier
     * @param {(number|Direction)} page la page a extraire
     */
    PaginateDataSource.prototype.getItemsByPage = function (page) {
        return this._paginator.paginate(page);
    };
    /**
     * redéclanche la navigation de la page en cours, si la page en cours n'est pas initialisé ou va sur la première
     * @param {boolean} forceUpdate indicateur pour redéclancher le requêtage
     */
    PaginateDataSource.prototype.reloadPage = function (forceUpdate) {
        if (forceUpdate === void 0) { forceUpdate = false; }
        if (forceUpdate) {
            this.goToPage(this.pagination.pageIndex || Direction.FIRST);
        }
        else {
            this.emit("pagination", { list: this.datasourceResults, pagination: this._paginator.pagination });
        }
    };
    /**
     * change le nombre d'items par page
     * @param {number} itemsPerPage items par page
     */
    PaginateDataSource.prototype.updatePerPage = function (itemsPerPage) {
        var _this = this;
        if (this.isDataSourceArray) {
            this.pagination.itemsPerPage = itemsPerPage;
            this.updatePaginator(this.datasourceResults);
            this.emit("pagination", { list: this._paginator.paginate(Direction.FIRST), pagination: this._paginator.pagination });
        }
        else {
            this.pagination.itemsPerPage = itemsPerPage;
            this._paginator.paginate(Direction.FIRST);
            this.fetchData(true, { criteres: this.fetchArgsSaved, pagination: this.pagination }).then(function (results) {
                _this.emit("pagination", { list: results, pagination: _this._paginator.pagination });
            });
        }
    };
    /***
     * @inheritdoc
     */
    PaginateDataSource.prototype.getFetchArgs = function (attrName, value, param) {
        var fetchArgs = param || {};
        if (!param && this.fetchArgsSaved) {
            fetchArgs[this.fetchAttrName] = this.fetchArgsSaved;
        }
        if (value) {
            fetchArgs[attrName] = value;
        }
        return fetchArgs;
    };
    /***
     * Supprime toute sélection dans le datasource.
     * @void
     */
    PaginateDataSource.prototype.selectClean = function (flag) {
        _super.prototype.selectClean.call(this, flag);
        this._paginator.reset();
    };
    /**
     * Sélectionne des items dans le datasource.
     * Dans le cadre d'un datasource paginate, les items devront obligatoirement avoir un attribut id pour être pris en compte.
     * @param {any[]} items les éléments à sélectionnés dans le datasource.
     * @param index de la ligne selectionnée
     */
    PaginateDataSource.prototype.select = function (items) {
        var temp = [];
        if (items)
            _.forEach(items, function (item) {
                if (item.id) {
                    temp.push(item);
                }
            });
        this._currentItemSelected = temp;
        this.emit('select', this._currentItemSelected);
    };
    /**
     * Enregistre la sélection courante dans le datasource.
     */
    PaginateDataSource.prototype.saveSelected = function () {
        this._selected = this.getAllSelected();
        this._currentItemSelected = undefined;
    };
    /**
     * Récupère la sélection courante + la selection existante
     * @returns {any}
     */
    PaginateDataSource.prototype.getAllSelected = function () {
        var result;
        if (this._selected && this._selected instanceof Array) {
            result = array_utils_1.ArrayUtils.unionWith(this._selected, this._currentItemSelected);
        }
        else {
            result = this._currentItemSelected;
        }
        return result;
    };
    Object.defineProperty(PaginateDataSource.prototype, "selected", {
        /**
         * renvoie les valeurs sélectionnées du datasource.
         */
        get: function () {
            return this.getAllSelected();
        },
        enumerable: true,
        configurable: true
    });
    return PaginateDataSource;
}(datasource_1.DataSource));
exports.PaginateDataSource = PaginateDataSource;

//# sourceMappingURL=paginate-datasource.js.map
