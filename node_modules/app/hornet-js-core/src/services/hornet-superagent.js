"use strict";
/**
 * Copyright ou © ou Copr. Ministère de l'Europe et des Affaires étrangères (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * Ce logiciel est un programme informatique servant à faciliter la création
 * d'applications Web conformément aux référentiels généraux français : RGI, RGS et RGAA
 * <p/>
 * Ce logiciel est régi par la licence CeCILL soumise au droit français et
 * respectant les principes de diffusion des logiciels libres. Vous pouvez
 * utiliser, modifier et/ou redistribuer ce programme sous les conditions
 * de la licence CeCILL telle que diffusée par le CEA, le CNRS et l'INRIA
 * sur le site "http://www.cecill.info".
 * <p/>
 * En contrepartie de l'accessibilité au code source et des droits de copie,
 * de modification et de redistribution accordés par cette licence, il n'est
 * offert aux utilisateurs qu'une garantie limitée.  Pour les mêmes raisons,
 * seule une responsabilité restreinte pèse sur l'auteur du programme,  le
 * titulaire des droits patrimoniaux et les concédants successifs.
 * <p/>
 * A cet égard  l'attention de l'utilisateur est attirée sur les risques
 * associés au chargement,  à l'utilisation,  à la modification et/ou au
 * développement et à la reproduction du logiciel par l'utilisateur étant
 * donné sa spécificité de logiciel libre, qui peut le rendre complexe à
 * manipuler et qui le réserve donc à des développeurs et des professionnels
 * avertis possédant  des  connaissances  informatiques approfondies.  Les
 * utilisateurs sont donc invités à charger  et  tester  l'adéquation  du
 * logiciel à leurs besoins dans des conditions permettant d'assurer la
 * sécurité de leurs systèmes et ou de leurs données et, plus généralement,
 * à l'utiliser et l'exploiter dans les mêmes conditions de sécurité.
 * <p/>
 * Le fait que vous puissiez accéder à cet en-tête signifie que vous avez
 * pris connaissance de la licence CeCILL, et que vous en avez accepté les
 * termes.
 * <p/>
 * <p/>
 * Copyright or © or Copr. Ministry for Europe and Foreign Affairs (2017)
 * <p/>
 * pole-architecture.dga-dsi-psi@diplomatie.gouv.fr
 * <p/>
 * This software is a computer program whose purpose is to facilitate creation of
 * web application in accordance with french general repositories : RGI, RGS and RGAA.
 * <p/>
 * This software is governed by the CeCILL license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * <p/>
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 * <p/>
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 * <p/>
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * hornet-js-core - Ensemble des composants qui forment le coeur de hornet-js
 *
 * @author MEAE - Ministère de l'Europe et des Affaires étrangères
 * @version v5.1.1
 * @link git+https://github.com/diplomatiegouvfr/hornet-js.git
 * @license CECILL-2.1
 */
var hornet_js_utils_1 = require("hornet-js-utils");
var _ = require("lodash");
var superagent = require("superagent");
var hornet_superagent_request_1 = require("hornet-js-core/src/services/hornet-superagent-request");
var hornet_event_1 = require("hornet-js-core/src/event/hornet-event");
var superAgentPlugins = require("hornet-js-core/src/services/superagent-hornet-plugins");
var media_type_1 = require("hornet-js-core/src/protocol/media-type");
var service_api_results_1 = require("hornet-js-core/src/services/service-api-results");
var error_manager_1 = require("hornet-js-core/src/component/error-manager");
var technical_error_1 = require("hornet-js-utils/src/exception/technical-error");
var hornet_cache_1 = require("hornet-js-core/src/cache/hornet-cache");
var hornet_event_2 = require("hornet-js-core/src/event/hornet-event");
var hornet_event_3 = require("hornet-js-core/src/event/hornet-event");
var base_error_1 = require("hornet-js-utils/src/exception/base-error");
var logger = hornet_js_utils_1.Utils.getLogger("hornet-js-core.services.hornet-agent");
var promise_api_1 = require("hornet-js-utils/src/promise-api");
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// wrap http & https afin de sécuriser l'utilisation de "continuation-local-storage" (perte ou mix de contexte) //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var http = require("http");
var https = require("https");
var disposition_type_1 = require("hornet-js-core/src/result/disposition-type");
if (http["__old_http_request"] == undefined) {
    http["__old_http_request"] = http.request;
    https["__old_https_reques"] = https.request;
    http.request = function () {
        var req = http["__old_http_request"].apply(http, arguments);
        hornet_js_utils_1.Utils.getContinuationStorage().bindEmitter(req);
        return req;
    };
    https.request = function () {
        var req = https["__old_https_reques"].apply(https, arguments);
        hornet_js_utils_1.Utils.getContinuationStorage().bindEmitter(req);
        return req;
    };
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var CacheKey;
(function (CacheKey) {
    CacheKey[CacheKey["URL"] = 0] = "URL";
    CacheKey[CacheKey["URL_DATA"] = 1] = "URL_DATA";
})(CacheKey = exports.CacheKey || (exports.CacheKey = {}));
;
exports.SESSION_WILL_EXPIRE_NOTIFICATION_EVENT = new hornet_event_2.HornetEvent("SESSION_WILL_EXPIRE");
exports.SESSION_WILL_EXPIRE_START_NOTIFICATION_EVENT = new hornet_event_2.HornetEvent("SESSION_WILL_EXPIRE_START");
exports.SESSION_REFRESHED_NOTIFICATION_EVENT = new hornet_event_2.HornetEvent("SESSION_REFRESHED");
/**
 * Cette classe sert à encapsuler les appels à SuperAgent pour ajouter des plugins au besoin
 * @class
 */
var HornetSuperAgent = /** @class */ (function () {
    function HornetSuperAgent(timeToliveInCache, cacheKey) {
        // configuration de la gestion des session des timeout côté client
        this.clientSessionConfig = {};
        // enable\disable le cache pour cette requête
        this.enableCache = false;
        // défini le mode de génération de clé pour le cache
        this.cacheKey = CacheKey.URL;
        // permet de désactiver l'évènement. Notamment utilisé pour l'affichage du spinner
        this.noEventFired = false;
        var plugins = [];
        var cacheConf = this.getCacheConfig();
        var globalCacheActivated = cacheConf.enabled;
        if (globalCacheActivated) {
            this.enableCache = true;
            if (_.isNumber(timeToliveInCache)) {
                this.timeToLiveInCache = timeToliveInCache;
            }
            else {
                this.timeToLiveInCache = cacheConf.timetolive || 3600;
            }
            if (cacheKey && CacheKey[cacheKey]) {
                this.cacheKey = cacheKey;
            }
            else {
                this.cacheKey = cacheConf.cacheKey || CacheKey.URL;
                if (!CacheKey[this.cacheKey]) {
                    this.cacheKey = CacheKey.URL;
                }
            }
            logger.debug("Activation du cache pour", this.timeToLiveInCache, "s");
        }
        else {
            logger.debug("Cache de requêtes désactivé, l'appel à cette méthode n'active donc PAS le cache");
        }
        if (!hornet_js_utils_1.Utils.isServer) {
            // Correction Bug IE Afin de pallier au problème de cache sur les services:
            plugins.push(new HornetPluginConfig("noCacheIEPlugin", superAgentPlugins.noCacheIEPlugin, null));
            plugins.push(new HornetPluginConfig("CsrfPlugin", superAgentPlugins.CsrfPlugin, null));
            plugins.push(new HornetPluginConfig("RedirectToLoginPagePlugin", superAgentPlugins.RedirectToLoginPagePlugin, null));
        }
        plugins.push(new HornetPluginConfig("AddParamFromLocalStorageTid", superAgentPlugins.AddParamFromLocalStorage, ["tid", "hornet.tid"]));
        plugins.push(new HornetPluginConfig("AddParamFromLocalStorageUser", superAgentPlugins.AddParam, ["user", (hornet_js_utils_1.Utils.getContinuationStorage().get("hornet.user") || {}).name]));
        this.plugins = new HornetList(plugins);
    }
    HornetSuperAgent.prototype.getCacheConfig = function () {
        var globalCache = hornet_js_utils_1.Utils.config.getIfExists("request.cache") || { enabled: false };
        if (globalCache) {
            if (!hornet_js_utils_1.Utils.isServer) {
                if (globalCache.client) {
                    globalCache = globalCache.client;
                }
            }
            else {
                if (globalCache.server) {
                    globalCache = globalCache.server;
                }
            }
        }
        return globalCache;
    };
    HornetSuperAgent.prototype.getClientSessionConfig = function () {
        if (!HornetSuperAgent.globalClientSessionConfig) {
            var clientSessionConf = (hornet_js_utils_1.Utils.appSharedProps.get("clientSessionConfig") || {});
            if (clientSessionConf && clientSessionConf.isInSessionTimeout == undefined) {
                clientSessionConf.isInSessionTimeout = clientSessionConf.notifSessionTimeout != undefined;
            }
            clientSessionConf.notifSessionTimeoutRepeat = clientSessionConf.notifSessionTimeoutRepeat || 600000;
            HornetSuperAgent.globalClientSessionConfig = clientSessionConf;
        }
        return HornetSuperAgent.globalClientSessionConfig;
    };
    HornetSuperAgent.prototype.getTimeoutConfig = function () {
        var request = hornet_js_utils_1.Utils.config.get("request");
        var timeout;
        if (request && request.timeout) {
            timeout = request.timeout;
        }
        return timeout;
    };
    /**
     * Initialise une instance de superagent en ajoutant les plugins et header
     * @returns {SuperAgentRequest}
     * @protected
     */
    HornetSuperAgent.prototype.initSuperAgent = function (request) {
        var _this = this;
        if (!hornet_js_utils_1.Utils.isServer) {
            _.merge(this.clientSessionConfig, this.getClientSessionConfig());
            _.merge(this.clientSessionConfig, request.clientTimeout);
        }
        if (!this.superAgentRequest) {
            this.superAgentRequest = superagent(request.method || "get", request.url);
            this.plugins.list.forEach(function (name) {
                var config = _this.plugins.mapPlugins["" + name];
                var fnt = config.clazz["getPlugin"];
                var plugin = fnt.apply(null, config.args);
                _this.superAgentRequest.use(plugin);
            });
            this.superAgentRequest.set("X-Requested-With", "XMLHttpRequest");
        }
        return this.superAgentRequest;
    };
    /**
     * Lancement des évents à lancer côté client lors d'une request
     * @param  boolean value indicateur de lancement ou reception d'une requete
     * @param  SpinnerType [spinner=SpinnerType.Default] type de gestion des spinner associés à la requête
     * @returns HornetAgent
     * */
    HornetSuperAgent.prototype.setClientEventForRequest = function (value, spinner) {
        if (spinner === void 0) { spinner = hornet_superagent_request_1.SpinnerType.Default; }
        /** Selection de l'évent à envoie côté client en fonction du spinner*/
        switch (spinner) {
            case hornet_superagent_request_1.SpinnerType.Component:
                hornet_event_1.ServiceEvent.setRequestComponentInProgress(value);
                break;
            case hornet_superagent_request_1.SpinnerType.Default:
                hornet_event_1.ServiceEvent.setRequestInProgress(value);
                break;
        }
    };
    /**
     * Methode executer sur l'envoi d'une requete (gestion spinner et du cache)
     * @param {HornetRequest} request requete à envoyer
     * @returns HornetAgent
     * */
    HornetSuperAgent.prototype.preProcessRequest = function (request) {
        if (!hornet_js_utils_1.Utils.isServer) {
            this.setClientEventForRequest(true, request.spinnerType);
        }
        if ((this.enableCache || request.timeToLiveInCache) && request.method === "get") {
            return this.getFromCache(request);
        }
        else if (this.enableCache && (request.method === "post" || request.method === "put" || request.method === "patch")) {
            return this.removeInCache(request);
        }
    };
    /**
     * Methode executer sur  la reception d'une requete (gestion spinner et du cache)
     * @param {HornetRequest} request requete envoyée
     * @param {Response} response réponse recue
     * @returns Response
     * */
    HornetSuperAgent.prototype.postProcessRequest = function (request, response) {
        if ((this.enableCache || request.timeToLiveInCache) && request.method === "get") {
            if (response && !request.noCached) {
                this.setInCache(response, request, request.timeToLiveInCache || this.timeToLiveInCache);
            }
        }
        else {
            if (!hornet_js_utils_1.Utils.isServer) {
                HornetSuperAgent.initSessionTimeout(this.clientSessionConfig);
            }
        }
        if (!hornet_js_utils_1.Utils.isServer) {
            this.setClientEventForRequest(false, request.spinnerType);
            return this.manageClientResult(response, request);
        }
        else {
            return this.manageServerResult(response, request);
        }
    };
    /**
     * send a request
     * @param {HornetRequest} request objet representant une requête (methode 'get' par defaut)
     * @param {NodeJS.WritableStream} pipedStream flux bindé sur la reponse superagent
     * @returns {Promise<Response>}
     */
    HornetSuperAgent.prototype.fetch = function (request, pipedStream) {
        var _this = this;
        return promise_api_1.Promise.resolve(true)
            .then(function () {
            return _this.preProcessRequest(request);
        }).then(function (cacheResponse) {
            var p;
            if (cacheResponse) {
                p = promise_api_1.Promise.resolve(cacheResponse);
            }
            else {
                p = new promise_api_1.Promise(function (resolve, reject) {
                    var ha = _this.initSuperAgent(request);
                    ha.accept((request.typeMime && request.typeMime.MIME) || "json"); // ajoute le format attendu sinon json par defaut
                    if (request.headers) {
                        for (var header in request.headers) {
                            ha.set(header, request.headers[header]);
                        }
                    }
                    if (!hornet_js_utils_1.Utils.isServer) {
                        if (request.typeMime && request.typeMime.MIME != media_type_1.MediaTypes.JSON.MIME) {
                            ha.responseType('blob');
                        }
                    }
                    if (request.ca)
                        ha.ca(request.ca);
                    if (request.key)
                        ha.key(request.key);
                    if (request.cert)
                        ha.cert(request.cert);
                    if (request.progress)
                        ha.on("progress", request.progress);
                    if (request.timeout) {
                        ha.timeout(request.timeout);
                    }
                    else {
                        ha.timeout(_this.getTimeoutConfig());
                    }
                    if (request.attach && request.attach.length > 0) {
                        ha.field("content", JSON.stringify(request.data));
                        request.attach.forEach(function (attachFile) {
                            ha.attach(attachFile.field, attachFile.file, attachFile.fileName);
                        });
                    }
                    else {
                        ha.type((request.headers && request.headers.contentType) || "json"); // ajoute le format envoyé sinon json par defaut
                        ha.send(request.data); // ajout du body
                    }
                    if (pipedStream) {
                        pipedStream['contentType'](request.typeMime.MIME);
                        pipedStream['attachment']("export." + request.typeMime.SHORT);
                        resolve(ha.pipe(pipedStream));
                    }
                    else {
                        resolve(ha); // lance la requete
                        /* equivalent
                        ha.end(function(err, res){
                            if (err) reject(err); else resolve(res);
                        });*/
                    }
                });
            }
            return p.then(function (response) {
                _this.response = response;
                return _this.postProcessRequest(request, response);
            });
        }).catch(function (e) {
            // en cas d'erreur un ferme le spinner
            _this.postProcessRequest(request, null);
            if (hornet_js_utils_1.Utils.isServer) {
                if (e.response && e.response.body && _this.hasHornetBody(e.response.body)) {
                    var result = e.response.body;
                    if (result.errors && result.errors.length != 0) {
                        // Erreur(s)
                        var execp = service_api_results_1.NodeApiError.parseError(result.errors, e.status).toJsError();
                        if (result.hasTechnicalError) {
                            throw execp;
                        }
                        else {
                            if (request.manageBusiness) {
                                return promise_api_1.Promise.reject(result);
                            }
                            else {
                                error_manager_1.manageError(execp, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                                return;
                            }
                        }
                    }
                }
            }
            else {
                if (e.response && e.response.body && _this.hasHornetBody(e.response.body)) {
                    var result = e.response.body;
                    if (result.errors && result.errors.length != 0) {
                        // NOTE: parameters are properties of the event detail property
                        var execp = service_api_results_1.NodeApiError.parseError(result.errors, e.status).toJsError();
                        // See Promise.onPossiblyUnhandledRejection for parameter documentation
                        if (result.hasTechnicalError) {
                            var err = service_api_results_1.NodeApiError.parseError(execp, null).toJsError();
                            error_manager_1.manageError(err, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                        }
                        else {
                            if (request.manageBusiness) {
                                return promise_api_1.Promise.reject(result);
                            }
                            else {
                                error_manager_1.manageError(execp, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                                return;
                            }
                        }
                    }
                }
                else {
                    var reason = (e["detail"] && e["detail"].reason) || e["reason"];
                    var promise = e["detail"] && e["detail"].promise;
                    if (!(reason instanceof base_error_1.BaseError)) {
                        var err_tech = new technical_error_1.TechnicalError('ERR_TECH_UNKNOWN', { errorMessage: "Erreur inattendue" }, reason || e);
                        var err = service_api_results_1.NodeApiError.parseError(err_tech, null).toJsError();
                        error_manager_1.manageError(err, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                    }
                    else {
                        if (e instanceof technical_error_1.TechnicalError) {
                            error_manager_1.manageError(e, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                        }
                        else {
                            if (request.manageBusiness) {
                                return promise_api_1.Promise.reject(e);
                            }
                            else {
                                error_manager_1.manageError(e, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                                return;
                            }
                        }
                    }
                }
            }
        });
    };
    /**
     * Formate la réponse pour le client afin de traiter les erreurs automatiquement
     * @param {Response} response reponse de superagent
     */
    HornetSuperAgent.prototype.manageClientResult = function (response, request) {
        // try catch car impossible de catcher les erreurs asynchrones sur le Client
        if (response) {
            if (response.body && this.hasHornetBody(response.body)) {
                // Result OK || Erreur gérée par node
                var result = response.body;
                if (result.errors.length == 0) {
                    return result.data;
                }
                else {
                    // Erreur(s)
                    var e = service_api_results_1.NodeApiError.parseError(result.errors, response.status).toJsError();
                    if (result.hasTechnicalError) {
                        var err = service_api_results_1.NodeApiError.parseError(e, null).toJsError();
                        error_manager_1.manageError(err, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                        return result;
                    }
                    else {
                        if (request.manageBusiness) {
                            return promise_api_1.Promise.reject({ response: response });
                        }
                        else {
                            error_manager_1.manageError(e, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
                            return;
                        }
                    }
                }
            }
            else {
                var regexp = response.header['content-type'].match(/([a-zA-Z]+)\/([a-zA-Z0-9.-]+)/);
                if ("application/json" != regexp[0].toLowerCase()) {
                    var attachFile = response.header['content-disposition'] ? response.header['content-disposition'].match(/(attachment|inline); filename="([^"]+)"/) : undefined;
                    var attachFilename = undefined;
                    // extract file name from header response
                    if (attachFile) {
                        attachFilename = attachFile[2];
                    }
                    else {
                        attachFilename = "export." + media_type_1.MediaTypes.fromMime(regexp[0]).SHORT;
                    }
                    var res = response["xhr"].response;
                    if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                        window.navigator.msSaveOrOpenBlob(res instanceof Blob ? res : new Blob([res], { "type": regexp[0] }), attachFilename);
                    }
                    else {
                        var objectUrl = window.URL.createObjectURL(res instanceof Blob ? res : new Blob([res], { "type": regexp[0] }), { oneTimeOnly: true }); // xhr.response is a blob 
                        if (!request.resultDisposition) {
                            if (!attachFile || attachFile[1] == disposition_type_1.DispositionType.ATTACHMENT) {
                                var elemt_1 = { a: null };
                                elemt_1.a = document.createElement('a');
                                elemt_1.a.href = objectUrl;
                                elemt_1.a.download = attachFilename; // Set the file name.
                                elemt_1.a.style.display = 'none';
                                document.body.appendChild(elemt_1.a);
                                elemt_1.a.click();
                                setTimeout(function () {
                                    document.body.removeChild(elemt_1.a);
                                    window.URL.revokeObjectURL(elemt_1.a.href);
                                    delete elemt_1.a;
                                }, 0);
                            }
                        }
                        else {
                            if (request.resultDisposition && request.resultDisposition.type == hornet_superagent_request_1.ResultDispositionType.Custom) {
                                return objectUrl;
                            }
                            else {
                                var data = request.resultDisposition.data || {};
                                window.open(objectUrl, data.name, data.specs, data.replace);
                            }
                        }
                    }
                }
            }
            return response;
        }
    };
    /**
     * Formate la réponse pour le serveur afin de traiter les erreurs automatiquement
     * @param {Response} response reponse de superagent
     */
    HornetSuperAgent.prototype.manageServerResult = function (response, request) {
        if (response && response.body && this.hasHornetBody(response.body)) {
            // Result OK || Erreur gérée par la backend
            var result = response.body;
            if (result.errors.length == 0) {
                // Pas d'erreur >> on appelle le cb fourni par l'application
                if (response.type && response.type != media_type_1.MediaTypes.JSON.MIME) {
                    return response;
                }
                return result.data;
            }
            else {
                throw service_api_results_1.BackendApiError.parseError(result.errors, response.status).toJsError();
            }
        }
        else {
            return response;
        }
    };
    /**
     * Test si c'est un format Hornet
     * @param {Response.body} body reponse de superagent
     */
    HornetSuperAgent.prototype.hasHornetBody = function (body) {
        return ["hasTechnicalError", "hasBusinessError", "status", "url", "data", "errors"].every(function (key) {
            return key in body;
        });
    };
    /**
     * Construction d'une erreur hornet et appel du manager d'erreurs
     */
    HornetSuperAgent.prototype.manageError = function (err) {
        // Erreur non gérée par le nodejs ! Réseau etc ...
        var error = new technical_error_1.TechnicalError("ERR_TECH_UNKNOWN", {
            errorMessage: err.message,
            httpStatus: 500 /*(TODO res || {url}).status*/,
            errorCause: err
        }, err);
        // pas de callback custom > on appelle le ClientErrorManager
        error_manager_1.manageError(error, hornet_js_utils_1.Utils.getCls("hornet.appConfig").errorComponent);
    };
    /**
     * Lecture dans le cache
     * @param {string} url url de la requête
     */
    HornetSuperAgent.prototype.getFromCache = function (request) {
        return hornet_cache_1.HornetCache.getInstance().getItem(this.generateCacheKey(request)).then(function (response) {
            logger.debug("Bypass appel API: retour du contenu du cache");
            return response;
        }).catch(function (e) {
            logger.trace(e);
            logger.debug("Pas de valeur en cache, appel de l'API");
        });
    };
    /**
     * Mise en cache de la reponse
     * @param {Response} response reponse de superagant
     * @param {HornetRequest} request requête à mettre en cache
     * @param {number} timetoliveInCache durée de vie dans le cache
     */
    HornetSuperAgent.prototype.setInCache = function (response, request, timetoliveInCache) {
        logger.debug("Mise en cache de la réponse à l'appel de l url:", request.url);
        var reponseCopy = this.cloneResponse(response);
        return hornet_cache_1.HornetCache
            .getInstance()
            .setCacheAsynchrone(this.generateCacheKey(request), reponseCopy, timetoliveInCache)
            .finally(function () {
            logger.debug("Sauvegarde dans le cache effectuée");
            return response;
        });
    };
    /**
     * Nettoyage en cache de la requete
     * @param {HornetRequest} request requête à mettre en cache
     */
    HornetSuperAgent.prototype.removeInCache = function (request) {
        logger.debug("Suppression en cache de l url:", request.url);
        var keys = [hornet_cache_1.HornetCache.getInstance().clearCacheAsynchrone(this.generateCacheKey(request)).catch(function (e) {
                logger.trace(e);
                logger.debug("Pas de valeur en cache à supprimer");
                return null;
            })];
        if (request.cacheLinkKey) {
            request.cacheLinkKey.forEach(function (key) {
                keys.push(hornet_cache_1.HornetCache.getInstance().clearCacheAsynchrone(key).catch(function (e) {
                    logger.trace(e);
                    logger.debug("Pas de valeur en cache à supprimer");
                    return null;
                }));
            });
        }
        promise_api_1.Promise.all(keys).then(function () {
            logger.debug("Suppression dans le cache effectuée");
            return null;
        });
        return promise_api_1.Promise.resolve(null);
    };
    /**
     * Génère la clé utilisée pour le cache
     * @param {HornetRequest} request requête pour la génération de la clé (url + param)
     */
    HornetSuperAgent.prototype.generateCacheKey = function (request) {
        var key = request.url;
        if (request.data && request.cacheKey == CacheKey.URL_DATA) {
            var separator = "?";
            var dataSort = Object.keys(request.data).sort();
            for (var data in dataSort) {
                key += separator + data + "=" + JSON.stringify(dataSort[data]);
                separator = "&";
            }
        }
        return key;
    };
    /**
     * clone les paramètres interessants d'une réponse.
     * La raison est que sur NodeJs la propriété 'body' n'est pas énumérable, on reconstruit donc un objet spécial pour le cache
     * Note: Possible de d'override cette méthode si d'autres paramètres doivent être ajoutés
     * @param res
     * @return {{body: (any|HTMLElement|req.body|{x-csrf-token}), header: any, ok: any, status: any, type: any}}
     * @protected
     */
    HornetSuperAgent.prototype.cloneResponse = function (res) {
        return {
            body: res.body,
            header: res.header,
            ok: res.ok,
            status: res.status,
            type: res.type
        };
    };
    ;
    /**
     * nettoyage des data (suppression des null (Button)).
     * @param {object} data
     * @protected
     */
    HornetSuperAgent.prototype.cleanData = function (data) {
        for (var attr in data) {
            if (data[attr] == null)
                delete data[attr];
        }
    };
    ;
    /**
     * initialise la méthode de timeout pour la notification de fin de session.
     * @param processing indicateur d'initialisation
     */
    HornetSuperAgent.initSessionTimeout = function (clientSessionConfig) {
        // On réinitialise l'expiration uniquement si une requète est transmise au serveur
        if (clientSessionConfig.isInSessionTimeout && !hornet_js_utils_1.Utils.isServer) {
            var expireIn = clientSessionConfig.sessionTimeout - clientSessionConfig.notifSessionTimeout;
            logger.debug("initSessionTimeout will notify in", clientSessionConfig.notifSessionTimeout, "ms");
            HornetSuperAgent.clear();
            HornetSuperAgent.sessionExpireTimeout = setTimeout(HornetSuperAgent.sessionWillExpireIn(clientSessionConfig.notifSessionTimeout), expireIn, clientSessionConfig);
        }
    };
    /**
     * Methode appelée sur le timeout de session côté client
     * @param expireIn
     */
    HornetSuperAgent.sessionWillExpireIn = function (expireIn) {
        return function (clientSessionConfig) {
            logger.debug("Session will expire in", expireIn, "ms");
            HornetSuperAgent.emitEvent(exports.SESSION_WILL_EXPIRE_START_NOTIFICATION_EVENT)(expireIn);
            var nextUpdateDelay = expireIn - clientSessionConfig.notifSessionTimeoutRepeat;
            HornetSuperAgent.sessionExpireTimeout = setTimeout(HornetSuperAgent.updateSessionWillExpireIn(nextUpdateDelay), clientSessionConfig.notifSessionTimeoutRepeat, clientSessionConfig);
        };
    };
    HornetSuperAgent.updateSessionWillExpireIn = function (expireIn) {
        return function (clientSessionConfig) {
            logger.debug("Session will expire in", expireIn, "ms");
            HornetSuperAgent.emitEvent(exports.SESSION_WILL_EXPIRE_NOTIFICATION_EVENT)(expireIn);
            var nextUpdateDelay = expireIn - clientSessionConfig.notifSessionTimeoutRepeat;
            if (nextUpdateDelay >= 0) {
                HornetSuperAgent.sessionExpireTimeout = setTimeout(HornetSuperAgent.updateSessionWillExpireIn(nextUpdateDelay), clientSessionConfig.notifSessionTimeoutRepeat, clientSessionConfig);
            }
        };
    };
    HornetSuperAgent.emitEvent = function (event) {
        return function (value) {
            hornet_event_3.fireHornetEvent(event.withData({ value: value }));
        };
    };
    HornetSuperAgent.clear = function () {
        clearTimeout(HornetSuperAgent.sessionExpireTimeout);
        HornetSuperAgent.emitEvent(exports.SESSION_REFRESHED_NOTIFICATION_EVENT)();
    };
    return HornetSuperAgent;
}());
exports.HornetSuperAgent = HornetSuperAgent;
var HornetPluginConfig = /** @class */ (function () {
    function HornetPluginConfig(name, clazz, args) {
        this.name = name;
        this.clazz = clazz;
        this.args = args;
    }
    return HornetPluginConfig;
}());
exports.HornetPluginConfig = HornetPluginConfig;
/**
 * Classe d'encapsulation de liste
 * @class
 */
var HornetList = /** @class */ (function () {
    function HornetList(list) {
        var _this = this;
        this.list = [];
        this.mapPlugins = {};
        list.forEach(function (pluginConfig) {
            _this.list.push(pluginConfig.name);
            _this.mapPlugins[pluginConfig["name"]] = pluginConfig;
        });
    }
    HornetList.prototype.addBefore = function (newElt, Elt) {
        var _this = this;
        var idx = -1;
        this.list.forEach(function (name, index) {
            idx = index;
            if (idx == -1 && name === Elt.name) {
                _this.mapPlugins[newElt["name"]] = newElt;
                idx = index;
            }
        });
        if (idx === -1) {
            throw new Error("L'élément de base n'a pas été trouvé dans le tableau " +
                ">> impossible d'insérer le nouvel élément avant.");
        }
        else {
            this.list.splice(idx, 0, newElt.name);
        }
        return this;
    };
    HornetList.prototype.addAfter = function (newElt, Elt) {
        var _this = this;
        var idx = -1;
        this.list.forEach(function (name, index) {
            idx = index;
            if (idx == -1 && name === Elt.name) {
                _this.mapPlugins[newElt["name"]] = newElt;
                idx = index;
            }
        });
        if (idx === -1) {
            throw new Error("L'élément de base n'a pas été trouvé dans le tableau " +
                ">> impossible d'insérer le nouvel élément après.");
        }
        else {
            this.list.splice(idx + 1, 0, newElt.name);
        }
        return this;
    };
    HornetList.prototype.remove = function (Elt) {
        var idx = -1;
        this.list.forEach(function (name, index) {
            idx = index;
            if (idx == -1 && name === Elt.name) {
                idx = index;
            }
        });
        if (idx === -1) {
            throw new Error("L'élément de base n'a pas été trouvé dans le tableau " +
                ">> suppression impossible.");
        }
        else {
            delete this.mapPlugins[Elt["name"]];
            this.list.splice(idx, 1);
        }
        return this;
    };
    HornetList.prototype.push = function (newElt) {
        this.mapPlugins[newElt["name"]] = newElt;
        this.list.push(newElt.name);
        return this;
    };
    return HornetList;
}());
exports.HornetList = HornetList;

//# sourceMappingURL=hornet-superagent.js.map
